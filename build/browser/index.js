(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.PYTOOLS = global.PYTOOLS || {})));
}(this, (function (exports) { 'use strict';

/**
 * Symbolic constants for various Python Language tokens.
 */
/**
 * Symbolic constants for various Python Language tokens.
 */ var Tokens;
(function (Tokens) {
    Tokens[Tokens["T_ENDMARKER"] = 0] = "T_ENDMARKER";
    Tokens[Tokens["T_NAME"] = 1] = "T_NAME";
    Tokens[Tokens["T_NUMBER"] = 2] = "T_NUMBER";
    Tokens[Tokens["T_STRING"] = 3] = "T_STRING";
    Tokens[Tokens["T_NEWLINE"] = 4] = "T_NEWLINE";
    Tokens[Tokens["T_INDENT"] = 5] = "T_INDENT";
    Tokens[Tokens["T_DEDENT"] = 6] = "T_DEDENT";
    Tokens[Tokens["T_LPAR"] = 7] = "T_LPAR";
    Tokens[Tokens["T_RPAR"] = 8] = "T_RPAR";
    Tokens[Tokens["T_LSQB"] = 9] = "T_LSQB";
    Tokens[Tokens["T_RSQB"] = 10] = "T_RSQB";
    Tokens[Tokens["T_COLON"] = 11] = "T_COLON";
    Tokens[Tokens["T_COMMA"] = 12] = "T_COMMA";
    Tokens[Tokens["T_SEMI"] = 13] = "T_SEMI";
    Tokens[Tokens["T_PLUS"] = 14] = "T_PLUS";
    Tokens[Tokens["T_MINUS"] = 15] = "T_MINUS";
    Tokens[Tokens["T_STAR"] = 16] = "T_STAR";
    Tokens[Tokens["T_SLASH"] = 17] = "T_SLASH";
    Tokens[Tokens["T_VBAR"] = 18] = "T_VBAR";
    Tokens[Tokens["T_AMPER"] = 19] = "T_AMPER";
    Tokens[Tokens["T_LESS"] = 20] = "T_LESS";
    Tokens[Tokens["T_GREATER"] = 21] = "T_GREATER";
    Tokens[Tokens["T_EQUAL"] = 22] = "T_EQUAL";
    Tokens[Tokens["T_DOT"] = 23] = "T_DOT";
    Tokens[Tokens["T_PERCENT"] = 24] = "T_PERCENT";
    Tokens[Tokens["T_BACKQUOTE"] = 25] = "T_BACKQUOTE";
    Tokens[Tokens["T_LBRACE"] = 26] = "T_LBRACE";
    Tokens[Tokens["T_RBRACE"] = 27] = "T_RBRACE";
    Tokens[Tokens["T_EQEQUAL"] = 28] = "T_EQEQUAL";
    Tokens[Tokens["T_NOTEQUAL"] = 29] = "T_NOTEQUAL";
    Tokens[Tokens["T_LESSEQUAL"] = 30] = "T_LESSEQUAL";
    Tokens[Tokens["T_GREATEREQUAL"] = 31] = "T_GREATEREQUAL";
    Tokens[Tokens["T_TILDE"] = 32] = "T_TILDE";
    Tokens[Tokens["T_CIRCUMFLEX"] = 33] = "T_CIRCUMFLEX";
    Tokens[Tokens["T_LEFTSHIFT"] = 34] = "T_LEFTSHIFT";
    Tokens[Tokens["T_RIGHTSHIFT"] = 35] = "T_RIGHTSHIFT";
    Tokens[Tokens["T_DOUBLESTAR"] = 36] = "T_DOUBLESTAR";
    Tokens[Tokens["T_PLUSEQUAL"] = 37] = "T_PLUSEQUAL";
    Tokens[Tokens["T_MINEQUAL"] = 38] = "T_MINEQUAL";
    Tokens[Tokens["T_STAREQUAL"] = 39] = "T_STAREQUAL";
    Tokens[Tokens["T_SLASHEQUAL"] = 40] = "T_SLASHEQUAL";
    Tokens[Tokens["T_PERCENTEQUAL"] = 41] = "T_PERCENTEQUAL";
    Tokens[Tokens["T_AMPEREQUAL"] = 42] = "T_AMPEREQUAL";
    Tokens[Tokens["T_VBAREQUAL"] = 43] = "T_VBAREQUAL";
    Tokens[Tokens["T_CIRCUMFLEXEQUAL"] = 44] = "T_CIRCUMFLEXEQUAL";
    Tokens[Tokens["T_LEFTSHIFTEQUAL"] = 45] = "T_LEFTSHIFTEQUAL";
    Tokens[Tokens["T_RIGHTSHIFTEQUAL"] = 46] = "T_RIGHTSHIFTEQUAL";
    Tokens[Tokens["T_DOUBLESTAREQUAL"] = 47] = "T_DOUBLESTAREQUAL";
    Tokens[Tokens["T_DOUBLESLASH"] = 48] = "T_DOUBLESLASH";
    Tokens[Tokens["T_DOUBLESLASHEQUAL"] = 49] = "T_DOUBLESLASHEQUAL";
    Tokens[Tokens["T_AT"] = 50] = "T_AT";
    Tokens[Tokens["T_OP"] = 51] = "T_OP";
    Tokens[Tokens["T_COMMENT"] = 52] = "T_COMMENT";
    Tokens[Tokens["T_NL"] = 53] = "T_NL";
    Tokens[Tokens["T_RARROW"] = 54] = "T_RARROW";
    Tokens[Tokens["T_ERRORTOKEN"] = 55] = "T_ERRORTOKEN";
    Tokens[Tokens["T_N_TOKENS"] = 56] = "T_N_TOKENS";
    Tokens[Tokens["T_NT_OFFSET"] = 256] = "T_NT_OFFSET";
})(Tokens || (Tokens = {}));

// DO NOT MODIFY. File automatically generated by pgen/parser/main.py
/**
 * Mapping from operator textual symbols to token symbolic constants.
 */
var OpMap = {
    "(": Tokens.T_LPAR,
    ")": Tokens.T_RPAR,
    "[": Tokens.T_LSQB,
    "]": Tokens.T_RSQB,
    ":": Tokens.T_COLON,
    ",": Tokens.T_COMMA,
    ";": Tokens.T_SEMI,
    "+": Tokens.T_PLUS,
    "-": Tokens.T_MINUS,
    "*": Tokens.T_STAR,
    "/": Tokens.T_SLASH,
    "|": Tokens.T_VBAR,
    "&": Tokens.T_AMPER,
    "<": Tokens.T_LESS,
    ">": Tokens.T_GREATER,
    "=": Tokens.T_EQUAL,
    ".": Tokens.T_DOT,
    "%": Tokens.T_PERCENT,
    "`": Tokens.T_BACKQUOTE,
    "{": Tokens.T_LBRACE,
    "}": Tokens.T_RBRACE,
    "@": Tokens.T_AT,
    "==": Tokens.T_EQEQUAL,
    "!=": Tokens.T_NOTEQUAL,
    "<>": Tokens.T_NOTEQUAL,
    "<=": Tokens.T_LESSEQUAL,
    ">=": Tokens.T_GREATEREQUAL,
    "~": Tokens.T_TILDE,
    "^": Tokens.T_CIRCUMFLEX,
    "<<": Tokens.T_LEFTSHIFT,
    ">>": Tokens.T_RIGHTSHIFT,
    "**": Tokens.T_DOUBLESTAR,
    "+=": Tokens.T_PLUSEQUAL,
    "-=": Tokens.T_MINEQUAL,
    "*=": Tokens.T_STAREQUAL,
    "/=": Tokens.T_SLASHEQUAL,
    "%=": Tokens.T_PERCENTEQUAL,
    "&=": Tokens.T_AMPEREQUAL,
    "|=": Tokens.T_VBAREQUAL,
    "^=": Tokens.T_CIRCUMFLEXEQUAL,
    "<<=": Tokens.T_LEFTSHIFTEQUAL,
    ">>=": Tokens.T_RIGHTSHIFTEQUAL,
    "**=": Tokens.T_DOUBLESTAREQUAL,
    "//": Tokens.T_DOUBLESLASH,
    "//=": Tokens.T_DOUBLESLASHEQUAL,
    "->": Tokens.T_RARROW
};
/**
 *
 */
var ParseTables = {
    sym: { AndExpr: 257,
        ArithmeticExpr: 258,
        AtomExpr: 259,
        BitwiseAndExpr: 260,
        BitwiseOrExpr: 261,
        BitwiseXorExpr: 262,
        ComparisonExpr: 263,
        ExprList: 264,
        ExprStmt: 265,
        GeometricExpr: 266,
        GlobalStmt: 267,
        IfExpr: 268,
        LambdaExpr: 269,
        NonLocalStmt: 270,
        NotExpr: 271,
        OrExpr: 272,
        PowerExpr: 273,
        ShiftExpr: 274,
        UnaryExpr: 275,
        YieldExpr: 276,
        arglist: 277,
        argument: 278,
        assert_stmt: 279,
        augassign: 280,
        break_stmt: 281,
        classdef: 282,
        comp_op: 283,
        compound_stmt: 284,
        continue_stmt: 285,
        decorated: 286,
        decorator: 287,
        decorators: 288,
        del_stmt: 289,
        dictmaker: 290,
        dotted_as_name: 291,
        dotted_as_names: 292,
        dotted_name: 293,
        encoding_decl: 294,
        eval_input: 295,
        except_clause: 296,
        exec_stmt: 297,
        file_input: 298,
        flow_stmt: 299,
        for_stmt: 300,
        fpdef: 301,
        fplist: 302,
        funcdef: 303,
        gen_for: 304,
        gen_if: 305,
        gen_iter: 306,
        if_stmt: 307,
        import_as_name: 308,
        import_as_names: 309,
        import_from: 310,
        import_name: 311,
        import_stmt: 312,
        list_for: 313,
        list_if: 314,
        list_iter: 315,
        listmaker: 316,
        old_LambdaExpr: 317,
        old_test: 318,
        parameters: 319,
        pass_stmt: 320,
        print_stmt: 321,
        raise_stmt: 322,
        return_stmt: 323,
        simple_stmt: 324,
        single_input: 256,
        sliceop: 325,
        small_stmt: 326,
        stmt: 327,
        subscript: 328,
        subscriptlist: 329,
        suite: 330,
        testlist: 331,
        testlist1: 332,
        testlist_gexp: 333,
        testlist_safe: 334,
        trailer: 335,
        try_stmt: 336,
        varargslist: 337,
        while_stmt: 338,
        with_stmt: 339,
        with_var: 340,
        yield_stmt: 341 },
    number2symbol: { 256: 'single_input',
        257: 'AndExpr',
        258: 'ArithmeticExpr',
        259: 'AtomExpr',
        260: 'BitwiseAndExpr',
        261: 'BitwiseOrExpr',
        262: 'BitwiseXorExpr',
        263: 'ComparisonExpr',
        264: 'ExprList',
        265: 'ExprStmt',
        266: 'GeometricExpr',
        267: 'GlobalStmt',
        268: 'IfExpr',
        269: 'LambdaExpr',
        270: 'NonLocalStmt',
        271: 'NotExpr',
        272: 'OrExpr',
        273: 'PowerExpr',
        274: 'ShiftExpr',
        275: 'UnaryExpr',
        276: 'YieldExpr',
        277: 'arglist',
        278: 'argument',
        279: 'assert_stmt',
        280: 'augassign',
        281: 'break_stmt',
        282: 'classdef',
        283: 'comp_op',
        284: 'compound_stmt',
        285: 'continue_stmt',
        286: 'decorated',
        287: 'decorator',
        288: 'decorators',
        289: 'del_stmt',
        290: 'dictmaker',
        291: 'dotted_as_name',
        292: 'dotted_as_names',
        293: 'dotted_name',
        294: 'encoding_decl',
        295: 'eval_input',
        296: 'except_clause',
        297: 'exec_stmt',
        298: 'file_input',
        299: 'flow_stmt',
        300: 'for_stmt',
        301: 'fpdef',
        302: 'fplist',
        303: 'funcdef',
        304: 'gen_for',
        305: 'gen_if',
        306: 'gen_iter',
        307: 'if_stmt',
        308: 'import_as_name',
        309: 'import_as_names',
        310: 'import_from',
        311: 'import_name',
        312: 'import_stmt',
        313: 'list_for',
        314: 'list_if',
        315: 'list_iter',
        316: 'listmaker',
        317: 'old_LambdaExpr',
        318: 'old_test',
        319: 'parameters',
        320: 'pass_stmt',
        321: 'print_stmt',
        322: 'raise_stmt',
        323: 'return_stmt',
        324: 'simple_stmt',
        325: 'sliceop',
        326: 'small_stmt',
        327: 'stmt',
        328: 'subscript',
        329: 'subscriptlist',
        330: 'suite',
        331: 'testlist',
        332: 'testlist1',
        333: 'testlist_gexp',
        334: 'testlist_safe',
        335: 'trailer',
        336: 'try_stmt',
        337: 'varargslist',
        338: 'while_stmt',
        339: 'with_stmt',
        340: 'with_var',
        341: 'yield_stmt' },
    dfas: { 256: [[[[1, 1], [2, 1], [3, 2]], [[0, 1]], [[2, 1]]],
            { 2: 1,
                4: 1,
                5: 1,
                6: 1,
                7: 1,
                8: 1,
                9: 1,
                10: 1,
                11: 1,
                12: 1,
                13: 1,
                14: 1,
                15: 1,
                16: 1,
                17: 1,
                18: 1,
                19: 1,
                20: 1,
                21: 1,
                22: 1,
                23: 1,
                24: 1,
                25: 1,
                26: 1,
                27: 1,
                28: 1,
                29: 1,
                30: 1,
                31: 1,
                32: 1,
                33: 1,
                34: 1,
                35: 1,
                36: 1,
                37: 1 }],
        257: [[[[38, 1]], [[39, 0], [0, 1]]],
            { 6: 1,
                7: 1,
                8: 1,
                9: 1,
                14: 1,
                18: 1,
                21: 1,
                25: 1,
                29: 1,
                32: 1,
                37: 1 }],
        258: [[[[40, 1]], [[25, 0], [37, 0], [0, 1]]],
            { 6: 1, 8: 1, 9: 1, 14: 1, 18: 1, 21: 1, 25: 1, 29: 1, 32: 1, 37: 1 }],
        259: [[[[18, 1], [8, 2], [9, 5], [29, 4], [32, 3], [14, 6], [21, 2]],
                [[18, 1], [0, 1]],
                [[0, 2]],
                [[41, 7], [42, 2]],
                [[43, 2], [44, 8], [45, 8]],
                [[46, 9], [47, 2]],
                [[48, 10]],
                [[42, 2]],
                [[43, 2]],
                [[47, 2]],
                [[14, 2]]],
            { 8: 1, 9: 1, 14: 1, 18: 1, 21: 1, 29: 1, 32: 1 }],
        260: [[[[49, 1]], [[50, 0], [0, 1]]],
            { 6: 1, 8: 1, 9: 1, 14: 1, 18: 1, 21: 1, 25: 1, 29: 1, 32: 1, 37: 1 }],
        261: [[[[51, 1]], [[52, 0], [0, 1]]],
            { 6: 1, 8: 1, 9: 1, 14: 1, 18: 1, 21: 1, 25: 1, 29: 1, 32: 1, 37: 1 }],
        262: [[[[53, 1]], [[54, 0], [0, 1]]],
            { 6: 1, 8: 1, 9: 1, 14: 1, 18: 1, 21: 1, 25: 1, 29: 1, 32: 1, 37: 1 }],
        263: [[[[55, 1]], [[56, 0], [0, 1]]],
            { 6: 1, 8: 1, 9: 1, 14: 1, 18: 1, 21: 1, 25: 1, 29: 1, 32: 1, 37: 1 }],
        264: [[[[55, 1]], [[57, 2], [0, 1]], [[55, 1], [0, 2]]],
            { 6: 1, 8: 1, 9: 1, 14: 1, 18: 1, 21: 1, 25: 1, 29: 1, 32: 1, 37: 1 }],
        265: [[[[58, 1]],
                [[59, 2], [60, 3], [0, 1]],
                [[58, 4], [45, 4]],
                [[58, 5], [45, 5]],
                [[0, 4]],
                [[60, 3], [0, 5]]],
            { 6: 1,
                7: 1,
                8: 1,
                9: 1,
                11: 1,
                14: 1,
                18: 1,
                21: 1,
                25: 1,
                29: 1,
                32: 1,
                37: 1 }],
        266: [[[[61, 1]], [[62, 0], [63, 0], [64, 0], [65, 0], [0, 1]]],
            { 6: 1, 8: 1, 9: 1, 14: 1, 18: 1, 21: 1, 25: 1, 29: 1, 32: 1, 37: 1 }],
        267: [[[[27, 1]], [[21, 2]], [[57, 1], [0, 2]]], { 27: 1 }],
        268: [[[[66, 1], [67, 2]],
                [[0, 1]],
                [[31, 3], [0, 2]],
                [[67, 4]],
                [[68, 5]],
                [[69, 1]]],
            { 6: 1,
                7: 1,
                8: 1,
                9: 1,
                11: 1,
                14: 1,
                18: 1,
                21: 1,
                25: 1,
                29: 1,
                32: 1,
                37: 1 }],
        269: [[[[11, 1]], [[70, 2], [71, 3]], [[69, 4]], [[70, 2]], [[0, 4]]],
            { 11: 1 }],
        270: [[[[13, 1]], [[21, 2]], [[57, 1], [0, 2]]], { 13: 1 }],
        271: [[[[7, 1], [72, 2]], [[38, 2]], [[0, 2]]],
            { 6: 1,
                7: 1,
                8: 1,
                9: 1,
                14: 1,
                18: 1,
                21: 1,
                25: 1,
                29: 1,
                32: 1,
                37: 1 }],
        272: [[[[73, 1]], [[74, 0], [0, 1]]],
            { 6: 1,
                7: 1,
                8: 1,
                9: 1,
                14: 1,
                18: 1,
                21: 1,
                25: 1,
                29: 1,
                32: 1,
                37: 1 }],
        273: [[[[75, 1]], [[76, 1], [77, 2], [0, 1]], [[49, 3]], [[0, 3]]],
            { 8: 1, 9: 1, 14: 1, 18: 1, 21: 1, 29: 1, 32: 1 }],
        274: [[[[78, 1]], [[79, 0], [80, 0], [0, 1]]],
            { 6: 1, 8: 1, 9: 1, 14: 1, 18: 1, 21: 1, 25: 1, 29: 1, 32: 1, 37: 1 }],
        275: [[[[25, 1], [6, 1], [37, 1], [81, 2]], [[49, 2]], [[0, 2]]],
            { 6: 1, 8: 1, 9: 1, 14: 1, 18: 1, 21: 1, 25: 1, 29: 1, 32: 1, 37: 1 }],
        276: [[[[26, 1]], [[58, 2], [0, 1]], [[0, 2]]], { 26: 1 }],
        277: [[[[63, 1], [82, 2], [77, 3]],
                [[69, 4]],
                [[57, 5], [0, 2]],
                [[69, 6]],
                [[57, 7], [0, 4]],
                [[63, 1], [82, 2], [77, 3], [0, 5]],
                [[0, 6]],
                [[82, 4], [77, 3]]],
            { 6: 1,
                7: 1,
                8: 1,
                9: 1,
                11: 1,
                14: 1,
                18: 1,
                21: 1,
                25: 1,
                29: 1,
                32: 1,
                37: 1,
                63: 1,
                77: 1 }],
        278: [[[[69, 1]], [[83, 2], [60, 3], [0, 1]], [[0, 2]], [[69, 2]]],
            { 6: 1,
                7: 1,
                8: 1,
                9: 1,
                11: 1,
                14: 1,
                18: 1,
                21: 1,
                25: 1,
                29: 1,
                32: 1,
                37: 1 }],
        279: [[[[20, 1]], [[69, 2]], [[57, 3], [0, 2]], [[69, 4]], [[0, 4]]],
            { 20: 1 }],
        280: [[[[84, 1],
                    [85, 1],
                    [86, 1],
                    [87, 1],
                    [88, 1],
                    [89, 1],
                    [90, 1],
                    [91, 1],
                    [92, 1],
                    [93, 1],
                    [94, 1],
                    [95, 1]],
                [[0, 1]]],
            { 84: 1,
                85: 1,
                86: 1,
                87: 1,
                88: 1,
                89: 1,
                90: 1,
                91: 1,
                92: 1,
                93: 1,
                94: 1,
                95: 1 }],
        281: [[[[33, 1]], [[0, 1]]], { 33: 1 }],
        282: [[[[10, 1]],
                [[21, 2]],
                [[70, 3], [29, 4]],
                [[96, 5]],
                [[43, 6], [58, 7]],
                [[0, 5]],
                [[70, 3]],
                [[43, 6]]],
            { 10: 1 }],
        283: [[[[97, 1],
                    [98, 1],
                    [7, 2],
                    [99, 1],
                    [97, 1],
                    [100, 1],
                    [101, 1],
                    [102, 3],
                    [103, 1],
                    [104, 1]],
                [[0, 1]],
                [[100, 1]],
                [[7, 1], [0, 3]]],
            { 7: 1, 97: 1, 98: 1, 99: 1, 100: 1, 101: 1, 102: 1, 103: 1, 104: 1 }],
        284: [[[[105, 1],
                    [106, 1],
                    [107, 1],
                    [108, 1],
                    [109, 1],
                    [110, 1],
                    [111, 1],
                    [112, 1]],
                [[0, 1]]],
            { 4: 1, 10: 1, 15: 1, 17: 1, 28: 1, 31: 1, 35: 1, 36: 1 }],
        285: [[[[34, 1]], [[0, 1]]], { 34: 1 }],
        286: [[[[113, 1]], [[111, 2], [108, 2]], [[0, 2]]], { 35: 1 }],
        287: [[[[35, 1]],
                [[114, 2]],
                [[2, 4], [29, 3]],
                [[43, 5], [115, 6]],
                [[0, 4]],
                [[2, 4]],
                [[43, 5]]],
            { 35: 1 }],
        288: [[[[116, 1]], [[116, 1], [0, 1]]], { 35: 1 }],
        289: [[[[22, 1]], [[117, 2]], [[0, 2]]], { 22: 1 }],
        290: [[[[69, 1]],
                [[70, 2]],
                [[69, 3]],
                [[57, 4], [0, 3]],
                [[69, 1], [0, 4]]],
            { 6: 1,
                7: 1,
                8: 1,
                9: 1,
                11: 1,
                14: 1,
                18: 1,
                21: 1,
                25: 1,
                29: 1,
                32: 1,
                37: 1 }],
        291: [[[[114, 1]], [[118, 2], [0, 1]], [[21, 3]], [[0, 3]]], { 21: 1 }],
        292: [[[[119, 1]], [[57, 0], [0, 1]]], { 21: 1 }],
        293: [[[[21, 1]], [[120, 0], [0, 1]]], { 21: 1 }],
        294: [[[[21, 1]], [[0, 1]]], { 21: 1 }],
        295: [[[[58, 1]], [[2, 1], [121, 2]], [[0, 2]]],
            { 6: 1,
                7: 1,
                8: 1,
                9: 1,
                11: 1,
                14: 1,
                18: 1,
                21: 1,
                25: 1,
                29: 1,
                32: 1,
                37: 1 }],
        296: [[[[122, 1]],
                [[69, 2], [0, 1]],
                [[118, 3], [57, 3], [0, 2]],
                [[69, 4]],
                [[0, 4]]],
            { 122: 1 }],
        297: [[[[16, 1]],
                [[55, 2]],
                [[100, 3], [0, 2]],
                [[69, 4]],
                [[57, 5], [0, 4]],
                [[69, 6]],
                [[0, 6]]],
            { 16: 1 }],
        298: [[[[2, 0], [121, 1], [123, 0]], [[0, 1]]],
            { 2: 1,
                4: 1,
                5: 1,
                6: 1,
                7: 1,
                8: 1,
                9: 1,
                10: 1,
                11: 1,
                12: 1,
                13: 1,
                14: 1,
                15: 1,
                16: 1,
                17: 1,
                18: 1,
                19: 1,
                20: 1,
                21: 1,
                22: 1,
                23: 1,
                24: 1,
                25: 1,
                26: 1,
                27: 1,
                28: 1,
                29: 1,
                30: 1,
                31: 1,
                32: 1,
                33: 1,
                34: 1,
                35: 1,
                36: 1,
                37: 1,
                121: 1 }],
        299: [[[[124, 1], [125, 1], [126, 1], [127, 1], [128, 1]], [[0, 1]]],
            { 5: 1, 19: 1, 26: 1, 33: 1, 34: 1 }],
        300: [[[[28, 1]],
                [[117, 2]],
                [[100, 3]],
                [[58, 4]],
                [[70, 5]],
                [[96, 6]],
                [[68, 7], [0, 6]],
                [[70, 8]],
                [[96, 9]],
                [[0, 9]]],
            { 28: 1 }],
        301: [[[[29, 1], [21, 2]], [[129, 3]], [[0, 2]], [[43, 2]]], { 21: 1, 29: 1 }],
        302: [[[[130, 1]], [[57, 2], [0, 1]], [[130, 1], [0, 2]]], { 21: 1, 29: 1 }],
        303: [[[[4, 1]], [[21, 2]], [[131, 3]], [[70, 4]], [[96, 5]], [[0, 5]]],
            { 4: 1 }],
        304: [[[[28, 1]],
                [[117, 2]],
                [[100, 3]],
                [[67, 4]],
                [[132, 5], [0, 4]],
                [[0, 5]]],
            { 28: 1 }],
        305: [[[[31, 1]], [[133, 2]], [[132, 3], [0, 2]], [[0, 3]]], { 31: 1 }],
        306: [[[[83, 1], [134, 1]], [[0, 1]]], { 28: 1, 31: 1 }],
        307: [[[[31, 1]],
                [[69, 2]],
                [[70, 3]],
                [[96, 4]],
                [[68, 5], [135, 1], [0, 4]],
                [[70, 6]],
                [[96, 7]],
                [[0, 7]]],
            { 31: 1 }],
        308: [[[[21, 1]], [[118, 2], [0, 1]], [[21, 3]], [[0, 3]]], { 21: 1 }],
        309: [[[[136, 1]], [[57, 2], [0, 1]], [[136, 1], [0, 2]]], { 21: 1 }],
        310: [[[[30, 1]],
                [[114, 2], [120, 3]],
                [[24, 4]],
                [[114, 2], [24, 4], [120, 3]],
                [[137, 5], [63, 5], [29, 6]],
                [[0, 5]],
                [[137, 7]],
                [[43, 5]]],
            { 30: 1 }],
        311: [[[[24, 1]], [[138, 2]], [[0, 2]]], { 24: 1 }],
        312: [[[[139, 1], [140, 1]], [[0, 1]]], { 24: 1, 30: 1 }],
        313: [[[[28, 1]],
                [[117, 2]],
                [[100, 3]],
                [[141, 4]],
                [[142, 5], [0, 4]],
                [[0, 5]]],
            { 28: 1 }],
        314: [[[[31, 1]], [[133, 2]], [[142, 3], [0, 2]], [[0, 3]]], { 31: 1 }],
        315: [[[[143, 1], [144, 1]], [[0, 1]]], { 28: 1, 31: 1 }],
        316: [[[[69, 1]],
                [[143, 2], [57, 3], [0, 1]],
                [[0, 2]],
                [[69, 4], [0, 3]],
                [[57, 3], [0, 4]]],
            { 6: 1,
                7: 1,
                8: 1,
                9: 1,
                11: 1,
                14: 1,
                18: 1,
                21: 1,
                25: 1,
                29: 1,
                32: 1,
                37: 1 }],
        317: [[[[11, 1]], [[70, 2], [71, 3]], [[133, 4]], [[70, 2]], [[0, 4]]],
            { 11: 1 }],
        318: [[[[145, 1], [67, 1]], [[0, 1]]],
            { 6: 1,
                7: 1,
                8: 1,
                9: 1,
                11: 1,
                14: 1,
                18: 1,
                21: 1,
                25: 1,
                29: 1,
                32: 1,
                37: 1 }],
        319: [[[[29, 1]], [[43, 2], [71, 3]], [[0, 2]], [[43, 2]]], { 29: 1 }],
        320: [[[[23, 1]], [[0, 1]]], { 23: 1 }],
        321: [[[[12, 1]],
                [[69, 2], [80, 3], [0, 1]],
                [[57, 4], [0, 2]],
                [[69, 5]],
                [[69, 2], [0, 4]],
                [[57, 6], [0, 5]],
                [[69, 7]],
                [[57, 8], [0, 7]],
                [[69, 7], [0, 8]]],
            { 12: 1 }],
        322: [[[[5, 1]],
                [[69, 2], [0, 1]],
                [[57, 3], [0, 2]],
                [[69, 4]],
                [[57, 5], [0, 4]],
                [[69, 6]],
                [[0, 6]]],
            { 5: 1 }],
        323: [[[[19, 1]], [[58, 2], [0, 1]], [[0, 2]]], { 19: 1 }],
        324: [[[[146, 1]], [[2, 2], [147, 3]], [[0, 2]], [[146, 1], [2, 2]]],
            { 5: 1,
                6: 1,
                7: 1,
                8: 1,
                9: 1,
                11: 1,
                12: 1,
                13: 1,
                14: 1,
                16: 1,
                18: 1,
                19: 1,
                20: 1,
                21: 1,
                22: 1,
                23: 1,
                24: 1,
                25: 1,
                26: 1,
                27: 1,
                29: 1,
                30: 1,
                32: 1,
                33: 1,
                34: 1,
                37: 1 }],
        325: [[[[70, 1]], [[69, 2], [0, 1]], [[0, 2]]], { 70: 1 }],
        326: [[[[148, 1],
                    [149, 1],
                    [150, 1],
                    [151, 1],
                    [152, 1],
                    [153, 1],
                    [154, 1],
                    [155, 1],
                    [156, 1],
                    [157, 1]],
                [[0, 1]]],
            { 5: 1,
                6: 1,
                7: 1,
                8: 1,
                9: 1,
                11: 1,
                12: 1,
                13: 1,
                14: 1,
                16: 1,
                18: 1,
                19: 1,
                20: 1,
                21: 1,
                22: 1,
                23: 1,
                24: 1,
                25: 1,
                26: 1,
                27: 1,
                29: 1,
                30: 1,
                32: 1,
                33: 1,
                34: 1,
                37: 1 }],
        327: [[[[1, 1], [3, 1]], [[0, 1]]],
            { 4: 1,
                5: 1,
                6: 1,
                7: 1,
                8: 1,
                9: 1,
                10: 1,
                11: 1,
                12: 1,
                13: 1,
                14: 1,
                15: 1,
                16: 1,
                17: 1,
                18: 1,
                19: 1,
                20: 1,
                21: 1,
                22: 1,
                23: 1,
                24: 1,
                25: 1,
                26: 1,
                27: 1,
                28: 1,
                29: 1,
                30: 1,
                31: 1,
                32: 1,
                33: 1,
                34: 1,
                35: 1,
                36: 1,
                37: 1 }],
        328: [[[[70, 1], [69, 2], [120, 3]],
                [[158, 4], [69, 5], [0, 1]],
                [[70, 1], [0, 2]],
                [[120, 6]],
                [[0, 4]],
                [[158, 4], [0, 5]],
                [[120, 4]]],
            { 6: 1,
                7: 1,
                8: 1,
                9: 1,
                11: 1,
                14: 1,
                18: 1,
                21: 1,
                25: 1,
                29: 1,
                32: 1,
                37: 1,
                70: 1,
                120: 1 }],
        329: [[[[159, 1]], [[57, 2], [0, 1]], [[159, 1], [0, 2]]],
            { 6: 1,
                7: 1,
                8: 1,
                9: 1,
                11: 1,
                14: 1,
                18: 1,
                21: 1,
                25: 1,
                29: 1,
                32: 1,
                37: 1,
                70: 1,
                120: 1 }],
        330: [[[[1, 1], [2, 2]],
                [[0, 1]],
                [[160, 3]],
                [[123, 4]],
                [[161, 1], [123, 4]]],
            { 2: 1,
                5: 1,
                6: 1,
                7: 1,
                8: 1,
                9: 1,
                11: 1,
                12: 1,
                13: 1,
                14: 1,
                16: 1,
                18: 1,
                19: 1,
                20: 1,
                21: 1,
                22: 1,
                23: 1,
                24: 1,
                25: 1,
                26: 1,
                27: 1,
                29: 1,
                30: 1,
                32: 1,
                33: 1,
                34: 1,
                37: 1 }],
        331: [[[[69, 1]], [[57, 2], [0, 1]], [[69, 1], [0, 2]]],
            { 6: 1,
                7: 1,
                8: 1,
                9: 1,
                11: 1,
                14: 1,
                18: 1,
                21: 1,
                25: 1,
                29: 1,
                32: 1,
                37: 1 }],
        332: [[[[69, 1]], [[57, 0], [0, 1]]],
            { 6: 1,
                7: 1,
                8: 1,
                9: 1,
                11: 1,
                14: 1,
                18: 1,
                21: 1,
                25: 1,
                29: 1,
                32: 1,
                37: 1 }],
        333: [[[[69, 1]],
                [[83, 2], [57, 3], [0, 1]],
                [[0, 2]],
                [[69, 4], [0, 3]],
                [[57, 3], [0, 4]]],
            { 6: 1,
                7: 1,
                8: 1,
                9: 1,
                11: 1,
                14: 1,
                18: 1,
                21: 1,
                25: 1,
                29: 1,
                32: 1,
                37: 1 }],
        334: [[[[133, 1]],
                [[57, 2], [0, 1]],
                [[133, 3]],
                [[57, 4], [0, 3]],
                [[133, 3], [0, 4]]],
            { 6: 1,
                7: 1,
                8: 1,
                9: 1,
                11: 1,
                14: 1,
                18: 1,
                21: 1,
                25: 1,
                29: 1,
                32: 1,
                37: 1 }],
        335: [[[[29, 1], [120, 2], [32, 3]],
                [[43, 4], [115, 5]],
                [[21, 4]],
                [[162, 6]],
                [[0, 4]],
                [[43, 4]],
                [[42, 4]]],
            { 29: 1, 32: 1, 120: 1 }],
        336: [[[[15, 1]],
                [[70, 2]],
                [[96, 3]],
                [[163, 4], [164, 5]],
                [[70, 6]],
                [[70, 7]],
                [[96, 8]],
                [[96, 9]],
                [[163, 4], [68, 10], [164, 5], [0, 8]],
                [[0, 9]],
                [[70, 11]],
                [[96, 12]],
                [[164, 5], [0, 12]]],
            { 15: 1 }],
        337: [[[[63, 1], [130, 2], [77, 3]],
                [[21, 4]],
                [[60, 5], [57, 6], [0, 2]],
                [[21, 7]],
                [[57, 8], [0, 4]],
                [[69, 9]],
                [[63, 1], [130, 2], [77, 3], [0, 6]],
                [[0, 7]],
                [[77, 3]],
                [[57, 6], [0, 9]]],
            { 21: 1, 29: 1, 63: 1, 77: 1 }],
        338: [[[[17, 1]],
                [[69, 2]],
                [[70, 3]],
                [[96, 4]],
                [[68, 5], [0, 4]],
                [[70, 6]],
                [[96, 7]],
                [[0, 7]]],
            { 17: 1 }],
        339: [[[[36, 1]],
                [[69, 2]],
                [[70, 3], [165, 4]],
                [[96, 5]],
                [[70, 3]],
                [[0, 5]]],
            { 36: 1 }],
        340: [[[[118, 1]], [[55, 2]], [[0, 2]]], { 118: 1 }],
        341: [[[[45, 1]], [[0, 1]]], { 26: 1 }] },
    states: [[[[1, 1], [2, 1], [3, 2]], [[0, 1]], [[2, 1]]],
        [[[38, 1]], [[39, 0], [0, 1]]],
        [[[40, 1]], [[25, 0], [37, 0], [0, 1]]],
        [[[18, 1], [8, 2], [9, 5], [29, 4], [32, 3], [14, 6], [21, 2]],
            [[18, 1], [0, 1]],
            [[0, 2]],
            [[41, 7], [42, 2]],
            [[43, 2], [44, 8], [45, 8]],
            [[46, 9], [47, 2]],
            [[48, 10]],
            [[42, 2]],
            [[43, 2]],
            [[47, 2]],
            [[14, 2]]],
        [[[49, 1]], [[50, 0], [0, 1]]],
        [[[51, 1]], [[52, 0], [0, 1]]],
        [[[53, 1]], [[54, 0], [0, 1]]],
        [[[55, 1]], [[56, 0], [0, 1]]],
        [[[55, 1]], [[57, 2], [0, 1]], [[55, 1], [0, 2]]],
        [[[58, 1]],
            [[59, 2], [60, 3], [0, 1]],
            [[58, 4], [45, 4]],
            [[58, 5], [45, 5]],
            [[0, 4]],
            [[60, 3], [0, 5]]],
        [[[61, 1]], [[62, 0], [63, 0], [64, 0], [65, 0], [0, 1]]],
        [[[27, 1]], [[21, 2]], [[57, 1], [0, 2]]],
        [[[66, 1], [67, 2]],
            [[0, 1]],
            [[31, 3], [0, 2]],
            [[67, 4]],
            [[68, 5]],
            [[69, 1]]],
        [[[11, 1]], [[70, 2], [71, 3]], [[69, 4]], [[70, 2]], [[0, 4]]],
        [[[13, 1]], [[21, 2]], [[57, 1], [0, 2]]],
        [[[7, 1], [72, 2]], [[38, 2]], [[0, 2]]],
        [[[73, 1]], [[74, 0], [0, 1]]],
        [[[75, 1]], [[76, 1], [77, 2], [0, 1]], [[49, 3]], [[0, 3]]],
        [[[78, 1]], [[79, 0], [80, 0], [0, 1]]],
        [[[25, 1], [6, 1], [37, 1], [81, 2]], [[49, 2]], [[0, 2]]],
        [[[26, 1]], [[58, 2], [0, 1]], [[0, 2]]],
        [[[63, 1], [82, 2], [77, 3]],
            [[69, 4]],
            [[57, 5], [0, 2]],
            [[69, 6]],
            [[57, 7], [0, 4]],
            [[63, 1], [82, 2], [77, 3], [0, 5]],
            [[0, 6]],
            [[82, 4], [77, 3]]],
        [[[69, 1]], [[83, 2], [60, 3], [0, 1]], [[0, 2]], [[69, 2]]],
        [[[20, 1]], [[69, 2]], [[57, 3], [0, 2]], [[69, 4]], [[0, 4]]],
        [[[84, 1],
                [85, 1],
                [86, 1],
                [87, 1],
                [88, 1],
                [89, 1],
                [90, 1],
                [91, 1],
                [92, 1],
                [93, 1],
                [94, 1],
                [95, 1]],
            [[0, 1]]],
        [[[33, 1]], [[0, 1]]],
        [[[10, 1]],
            [[21, 2]],
            [[70, 3], [29, 4]],
            [[96, 5]],
            [[43, 6], [58, 7]],
            [[0, 5]],
            [[70, 3]],
            [[43, 6]]],
        [[[97, 1],
                [98, 1],
                [7, 2],
                [99, 1],
                [97, 1],
                [100, 1],
                [101, 1],
                [102, 3],
                [103, 1],
                [104, 1]],
            [[0, 1]],
            [[100, 1]],
            [[7, 1], [0, 3]]],
        [[[105, 1],
                [106, 1],
                [107, 1],
                [108, 1],
                [109, 1],
                [110, 1],
                [111, 1],
                [112, 1]],
            [[0, 1]]],
        [[[34, 1]], [[0, 1]]],
        [[[113, 1]], [[111, 2], [108, 2]], [[0, 2]]],
        [[[35, 1]],
            [[114, 2]],
            [[2, 4], [29, 3]],
            [[43, 5], [115, 6]],
            [[0, 4]],
            [[2, 4]],
            [[43, 5]]],
        [[[116, 1]], [[116, 1], [0, 1]]],
        [[[22, 1]], [[117, 2]], [[0, 2]]],
        [[[69, 1]], [[70, 2]], [[69, 3]], [[57, 4], [0, 3]], [[69, 1], [0, 4]]],
        [[[114, 1]], [[118, 2], [0, 1]], [[21, 3]], [[0, 3]]],
        [[[119, 1]], [[57, 0], [0, 1]]],
        [[[21, 1]], [[120, 0], [0, 1]]],
        [[[21, 1]], [[0, 1]]],
        [[[58, 1]], [[2, 1], [121, 2]], [[0, 2]]],
        [[[122, 1]],
            [[69, 2], [0, 1]],
            [[118, 3], [57, 3], [0, 2]],
            [[69, 4]],
            [[0, 4]]],
        [[[16, 1]],
            [[55, 2]],
            [[100, 3], [0, 2]],
            [[69, 4]],
            [[57, 5], [0, 4]],
            [[69, 6]],
            [[0, 6]]],
        [[[2, 0], [121, 1], [123, 0]], [[0, 1]]],
        [[[124, 1], [125, 1], [126, 1], [127, 1], [128, 1]], [[0, 1]]],
        [[[28, 1]],
            [[117, 2]],
            [[100, 3]],
            [[58, 4]],
            [[70, 5]],
            [[96, 6]],
            [[68, 7], [0, 6]],
            [[70, 8]],
            [[96, 9]],
            [[0, 9]]],
        [[[29, 1], [21, 2]], [[129, 3]], [[0, 2]], [[43, 2]]],
        [[[130, 1]], [[57, 2], [0, 1]], [[130, 1], [0, 2]]],
        [[[4, 1]], [[21, 2]], [[131, 3]], [[70, 4]], [[96, 5]], [[0, 5]]],
        [[[28, 1]], [[117, 2]], [[100, 3]], [[67, 4]], [[132, 5], [0, 4]], [[0, 5]]],
        [[[31, 1]], [[133, 2]], [[132, 3], [0, 2]], [[0, 3]]],
        [[[83, 1], [134, 1]], [[0, 1]]],
        [[[31, 1]],
            [[69, 2]],
            [[70, 3]],
            [[96, 4]],
            [[68, 5], [135, 1], [0, 4]],
            [[70, 6]],
            [[96, 7]],
            [[0, 7]]],
        [[[21, 1]], [[118, 2], [0, 1]], [[21, 3]], [[0, 3]]],
        [[[136, 1]], [[57, 2], [0, 1]], [[136, 1], [0, 2]]],
        [[[30, 1]],
            [[114, 2], [120, 3]],
            [[24, 4]],
            [[114, 2], [24, 4], [120, 3]],
            [[137, 5], [63, 5], [29, 6]],
            [[0, 5]],
            [[137, 7]],
            [[43, 5]]],
        [[[24, 1]], [[138, 2]], [[0, 2]]],
        [[[139, 1], [140, 1]], [[0, 1]]],
        [[[28, 1]], [[117, 2]], [[100, 3]], [[141, 4]], [[142, 5], [0, 4]], [[0, 5]]],
        [[[31, 1]], [[133, 2]], [[142, 3], [0, 2]], [[0, 3]]],
        [[[143, 1], [144, 1]], [[0, 1]]],
        [[[69, 1]],
            [[143, 2], [57, 3], [0, 1]],
            [[0, 2]],
            [[69, 4], [0, 3]],
            [[57, 3], [0, 4]]],
        [[[11, 1]], [[70, 2], [71, 3]], [[133, 4]], [[70, 2]], [[0, 4]]],
        [[[145, 1], [67, 1]], [[0, 1]]],
        [[[29, 1]], [[43, 2], [71, 3]], [[0, 2]], [[43, 2]]],
        [[[23, 1]], [[0, 1]]],
        [[[12, 1]],
            [[69, 2], [80, 3], [0, 1]],
            [[57, 4], [0, 2]],
            [[69, 5]],
            [[69, 2], [0, 4]],
            [[57, 6], [0, 5]],
            [[69, 7]],
            [[57, 8], [0, 7]],
            [[69, 7], [0, 8]]],
        [[[5, 1]],
            [[69, 2], [0, 1]],
            [[57, 3], [0, 2]],
            [[69, 4]],
            [[57, 5], [0, 4]],
            [[69, 6]],
            [[0, 6]]],
        [[[19, 1]], [[58, 2], [0, 1]], [[0, 2]]],
        [[[146, 1]], [[2, 2], [147, 3]], [[0, 2]], [[146, 1], [2, 2]]],
        [[[70, 1]], [[69, 2], [0, 1]], [[0, 2]]],
        [[[148, 1],
                [149, 1],
                [150, 1],
                [151, 1],
                [152, 1],
                [153, 1],
                [154, 1],
                [155, 1],
                [156, 1],
                [157, 1]],
            [[0, 1]]],
        [[[1, 1], [3, 1]], [[0, 1]]],
        [[[70, 1], [69, 2], [120, 3]],
            [[158, 4], [69, 5], [0, 1]],
            [[70, 1], [0, 2]],
            [[120, 6]],
            [[0, 4]],
            [[158, 4], [0, 5]],
            [[120, 4]]],
        [[[159, 1]], [[57, 2], [0, 1]], [[159, 1], [0, 2]]],
        [[[1, 1], [2, 2]], [[0, 1]], [[160, 3]], [[123, 4]], [[161, 1], [123, 4]]],
        [[[69, 1]], [[57, 2], [0, 1]], [[69, 1], [0, 2]]],
        [[[69, 1]], [[57, 0], [0, 1]]],
        [[[69, 1]],
            [[83, 2], [57, 3], [0, 1]],
            [[0, 2]],
            [[69, 4], [0, 3]],
            [[57, 3], [0, 4]]],
        [[[133, 1]],
            [[57, 2], [0, 1]],
            [[133, 3]],
            [[57, 4], [0, 3]],
            [[133, 3], [0, 4]]],
        [[[29, 1], [120, 2], [32, 3]],
            [[43, 4], [115, 5]],
            [[21, 4]],
            [[162, 6]],
            [[0, 4]],
            [[43, 4]],
            [[42, 4]]],
        [[[15, 1]],
            [[70, 2]],
            [[96, 3]],
            [[163, 4], [164, 5]],
            [[70, 6]],
            [[70, 7]],
            [[96, 8]],
            [[96, 9]],
            [[163, 4], [68, 10], [164, 5], [0, 8]],
            [[0, 9]],
            [[70, 11]],
            [[96, 12]],
            [[164, 5], [0, 12]]],
        [[[63, 1], [130, 2], [77, 3]],
            [[21, 4]],
            [[60, 5], [57, 6], [0, 2]],
            [[21, 7]],
            [[57, 8], [0, 4]],
            [[69, 9]],
            [[63, 1], [130, 2], [77, 3], [0, 6]],
            [[0, 7]],
            [[77, 3]],
            [[57, 6], [0, 9]]],
        [[[17, 1]],
            [[69, 2]],
            [[70, 3]],
            [[96, 4]],
            [[68, 5], [0, 4]],
            [[70, 6]],
            [[96, 7]],
            [[0, 7]]],
        [[[36, 1]], [[69, 2]], [[70, 3], [165, 4]], [[96, 5]], [[70, 3]], [[0, 5]]],
        [[[118, 1]], [[55, 2]], [[0, 2]]],
        [[[45, 1]], [[0, 1]]]],
    labels: [[0, 'EMPTY'],
        [324, null],
        [4, null],
        [284, null],
        [1, 'def'],
        [1, 'raise'],
        [32, null],
        [1, 'not'],
        [2, null],
        [26, null],
        [1, 'class'],
        [1, 'lambda'],
        [1, 'print'],
        [1, 'nonlocal'],
        [25, null],
        [1, 'try'],
        [1, 'exec'],
        [1, 'while'],
        [3, null],
        [1, 'return'],
        [1, 'assert'],
        [1, null],
        [1, 'del'],
        [1, 'pass'],
        [1, 'import'],
        [15, null],
        [1, 'yield'],
        [1, 'global'],
        [1, 'for'],
        [7, null],
        [1, 'from'],
        [1, 'if'],
        [9, null],
        [1, 'break'],
        [1, 'continue'],
        [50, null],
        [1, 'with'],
        [14, null],
        [271, null],
        [1, 'and'],
        [266, null],
        [316, null],
        [10, null],
        [8, null],
        [333, null],
        [276, null],
        [290, null],
        [27, null],
        [332, null],
        [275, null],
        [19, null],
        [262, null],
        [18, null],
        [260, null],
        [33, null],
        [258, null],
        [283, null],
        [12, null],
        [331, null],
        [280, null],
        [22, null],
        [274, null],
        [48, null],
        [16, null],
        [17, null],
        [24, null],
        [269, null],
        [272, null],
        [1, 'else'],
        [268, null],
        [11, null],
        [337, null],
        [263, null],
        [257, null],
        [1, 'or'],
        [259, null],
        [335, null],
        [36, null],
        [261, null],
        [34, null],
        [35, null],
        [273, null],
        [278, null],
        [304, null],
        [46, null],
        [39, null],
        [41, null],
        [47, null],
        [42, null],
        [43, null],
        [37, null],
        [44, null],
        [49, null],
        [45, null],
        [38, null],
        [40, null],
        [330, null],
        [29, null],
        [21, null],
        [28, null],
        [1, 'in'],
        [30, null],
        [1, 'is'],
        [31, null],
        [20, null],
        [336, null],
        [307, null],
        [300, null],
        [282, null],
        [339, null],
        [338, null],
        [303, null],
        [286, null],
        [288, null],
        [293, null],
        [277, null],
        [287, null],
        [264, null],
        [1, 'as'],
        [291, null],
        [23, null],
        [0, null],
        [1, 'except'],
        [327, null],
        [281, null],
        [285, null],
        [322, null],
        [323, null],
        [341, null],
        [302, null],
        [301, null],
        [319, null],
        [306, null],
        [318, null],
        [305, null],
        [1, 'elif'],
        [308, null],
        [309, null],
        [292, null],
        [311, null],
        [310, null],
        [334, null],
        [315, null],
        [313, null],
        [314, null],
        [317, null],
        [326, null],
        [13, null],
        [299, null],
        [270, null],
        [265, null],
        [320, null],
        [267, null],
        [321, null],
        [289, null],
        [297, null],
        [279, null],
        [312, null],
        [325, null],
        [328, null],
        [5, null],
        [6, null],
        [329, null],
        [296, null],
        [1, 'finally'],
        [340, null]],
    keywords: { 'and': 39,
        'as': 118,
        'assert': 20,
        'break': 33,
        'class': 10,
        'continue': 34,
        'def': 4,
        'del': 22,
        'elif': 135,
        'else': 68,
        'except': 122,
        'exec': 16,
        'finally': 164,
        'for': 28,
        'from': 30,
        'global': 27,
        'if': 31,
        'import': 24,
        'in': 100,
        'is': 102,
        'lambda': 11,
        'nonlocal': 13,
        'not': 7,
        'or': 74,
        'pass': 23,
        'print': 12,
        'raise': 5,
        'return': 19,
        'try': 15,
        'while': 17,
        'with': 36,
        'yield': 26 },
    tokens: { 0: 121,
        1: 21,
        2: 8,
        3: 18,
        4: 2,
        5: 160,
        6: 161,
        7: 29,
        8: 43,
        9: 32,
        10: 42,
        11: 70,
        12: 57,
        13: 147,
        14: 37,
        15: 25,
        16: 63,
        17: 64,
        18: 52,
        19: 50,
        20: 104,
        21: 98,
        22: 60,
        23: 120,
        24: 65,
        25: 14,
        26: 9,
        27: 47,
        28: 99,
        29: 97,
        30: 101,
        31: 103,
        32: 6,
        33: 54,
        34: 79,
        35: 80,
        36: 77,
        37: 90,
        38: 94,
        39: 85,
        40: 95,
        41: 86,
        42: 88,
        43: 89,
        44: 91,
        45: 93,
        46: 84,
        47: 87,
        48: 62,
        49: 92,
        50: 35 },
    start: 256
};
// Nothing more to see here.

/**
 * We're looking for something that is truthy, not just true.
 */
/**
 * We're looking for something that is truthy, not just true.
 */ function assert(condition, message) {
    if (!condition) {
        throw new Error(message);
    }
}
function fail(message) {
    assert(false, message);
}

/**
 * Returns the number of children in the specified node.
 */
function NCH(n) {
    assert(n !== undefined);
    if (Array.isArray(n.children)) {
        return n.children.length;
    }
    else {
        return 0;
    }
}
function CHILD(n, i) {
    assert(i !== undefined);
    return CHILDREN(n)[i];
}
function CHILDREN(n) {
    assert(n !== undefined);
    if (n.children) {
        return n.children;
    }
    else {
        throw new Error("node does not have any children");
    }
}
function IDXLAST(xs) {
    return xs.length - 1;
}
/**
 * Returns the terminal nodes of the tree.
 */

/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */
/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */ 
/**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = base.abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * Note: This does not take the name of the function to override as an argument
 * because that would make it more difficult to obfuscate our JavaScript code.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 */

// ==============================================================================
// Language Enhancements
// ==============================================================================
/**
 * This is a "fixed" version of the typeof operator.  It differs from the typeof
 * operator in such a way that null returns 'null' and arrays return 'array'.
 * @param {*} value The value to get the type of.
 * @return {string} The name of the type.
 */
function typeOf(value) {
    var s = typeof value;
    if (s === 'object') {
        if (value) {
            // Check these first, so we can avoid calling Object.prototype.toString if
            // possible.
            //
            // IE improperly marshals tyepof across execution contexts, but a
            // cross-context object will still return false for "instanceof Object".
            if (value instanceof Array) {
                return 'array';
            }
            else if (value instanceof Object) {
                return s;
            }
            // HACK: In order to use an Object prototype method on the arbitrary
            //   value, the compiler requires the value be cast to type Object,
            //   even though the ECMA spec explicitly allows it.
            var className = Object.prototype.toString.call(
            /** @type {Object} */ (value));
            // In Firefox 3.6, attempting to access iframe window objects' length
            // property throws an NS_ERROR_FAILURE, so we need to special-case it
            // here.
            if (className === '[object Window]') {
                return 'object';
            }
            // We cannot always use constructor == Array or instanceof Array because
            // different frames have different Array objects. In IE6, if the iframe
            // where the array was created is destroyed, the array loses its
            // prototype. Then dereferencing val.splice here throws an exception, so
            // we can't use base.isFunction. Calling typeof directly returns 'unknown'
            // so that will work. In this case, this function will return false and
            // most array functions will still work because the array is still
            // array-like (supports length and []) even though it has lost its
            // prototype.
            // Mark Miller noticed that Object.prototype.toString
            // allows access to the unforgeable [[Class]] property.
            //  15.2.4.2 Object.prototype.toString ( )
            //  When the toString method is called, the following steps are taken:
            //      1. Get the [[Class]] property of this object.
            //      2. Compute a string value by concatenating the three strings
            //         "[object ", Result(1), and "]".
            //      3. Return Result(2).
            // and this behavior survives the destruction of the execution context.
            if ((className === '[object Array]' ||
                // In IE all non value types are wrapped as objects across window
                // boundaries (not iframe though) so we have to do object detection
                // for this edge case.
                typeof value.length === 'number' &&
                    typeof value.splice !== 'undefined' &&
                    typeof value.propertyIsEnumerable !== 'undefined' &&
                    !value.propertyIsEnumerable('splice'))) {
                return 'array';
            }
            // HACK: There is still an array case that fails.
            //     function ArrayImpostor() {}
            //     ArrayImpostor.prototype = [];
            //     var impostor = new ArrayImpostor;
            // this can be fixed by getting rid of the fast path
            // (value instanceof Array) and solely relying on
            // (value && Object.prototype.toString.vall(value) === '[object Array]')
            // but that would require many more function calls and is not warranted
            // unless closure code is receiving objects from untrusted sources.
            // IE in cross-window calls does not correctly marshal the function type
            // (it appears just as an object) so we cannot use just typeof val ==
            // 'function'. However, if the object has a call property, it is a
            // function.
            if ((className === '[object Function]' ||
                typeof value.call !== 'undefined' &&
                    typeof value.propertyIsEnumerable !== 'undefined' &&
                    !value.propertyIsEnumerable('call'))) {
                return 'function';
            }
        }
        else {
            return 'null';
        }
    }
    else if (s === 'function' && typeof value.call === 'undefined') {
        // In Safari typeof nodeList returns 'function', and on Firefox typeof
        // behaves similarly for HTML{Applet,Embed,Object}, Elements and RegExps. We
        // would like to return object for those and we can detect an invalid
        // function by making sure that the function object has a call method.
        return 'object';
    }
    return s;
}
/**
 * Returns true if the specified value is not undefined.
 * WARNING: Do not use this to test if an object has a property. Use the in
 * operator instead.  Additionally, this function assumes that the global
 * undefined variable has not been redefined.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */
function isDef(val) {
    return val !== undefined;
}
/**
 * Returns true if the specified value is null.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is null.
 */

/**
 * Returns true if the specified value is defined and not null.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is defined and not null.
 */

/**
 * Returns true if the specified value is an array.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
function isArray(val) {
    return typeOf(val) === 'array';
}
/**
 * Returns true if the object looks like an array. To qualify as array like
 * the value needs to be either a NodeList or an object with a Number length
 * property.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
function isArrayLike(val) {
    var type = typeOf(val);
    return type === 'array' || type === 'object' && typeof val.length === 'number';
}
/**
 * Returns true if the object looks like a Date. To qualify as Date-like the
 * value needs to be an object and have a getFullYear() function.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is a like a Date.
 */

/**
 * Returns true if the specified value is a string.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is a string.
 */
function isString(val) {
    return typeof val === 'string';
}
/**
 * Returns true if the specified value is a boolean.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */

/**
 * Returns true if the specified value is a number.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */
function isNumber(val) {
    return typeof val === 'number';
}
/**
 * Returns true if the specified value is a function.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */

/**
 * Returns true if the specified value is an object.  This includes arrays and
 * functions.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */

/**
 *
 */
var TokenError = (function () {
    function TokenError(message, lineNumber, columnNumber) {
        assert(isString(message), "message must be a string");
        assert(isNumber(lineNumber), "lineNumber must be a number");
        assert(isNumber(columnNumber), "columnNumber must be a number");
        this.name = "TokenError";
        this.message = message;
        this.lineNumber = lineNumber;
        this.columnNumber = columnNumber;
    }
    return TokenError;
}());

/* we have to use string and ctor to be able to build patterns up. + on /.../
    * does something strange. */
// const Whitespace = "[ \\f\\t]*";
var Comment_ = "#[^\\r\\n]*";
var Ident = "[a-zA-Z_]\\w*";
var Binnumber = '0[bB][01]*';
var Hexnumber = '0[xX][\\da-fA-F]*[lL]?';
var Octnumber = '0[oO]?[0-7]*[lL]?';
var Decnumber = '[1-9]\\d*[lL]?';
var Intnumber = group(Binnumber, Hexnumber, Octnumber, Decnumber);
var Exponent = "[eE][-+]?\\d+";
var Pointfloat = group("\\d+\\.\\d*", "\\.\\d+") + maybe(Exponent);
var Expfloat = '\\d+' + Exponent;
var Floatnumber = group(Pointfloat, Expfloat);
var Imagnumber = group("\\d+[jJ]", Floatnumber + "[jJ]");
var Number_ = group(Imagnumber, Floatnumber, Intnumber);
// tail end of ' string
var Single = "^[^'\\\\]*(?:\\\\.[^'\\\\]*)*'";
// tail end of " string
var Double_ = '^[^"\\\\]*(?:\\\\.[^"\\\\]*)*"';
// tail end of ''' string
var Single3 = "[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*'''";
// tail end of """ string
var Double3 = '[^"\\\\]*(?:(?:\\\\.|"(?!""))[^"\\\\]*)*"""';
var Triple = group("[ubUB]?[rR]?'''", '[ubUB]?[rR]?"""');
// const String_ = group("[uU]?[rR]?'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'", '[uU]?[rR]?"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*"');
// Because of leftmost-then-longest match semantics, be sure to put the
// longest operators first (e.g., if = came before ==, == would get
// recognized as two instances of =).
var Operator = group("\\*\\*=?", ">>=?", "<<=?", "<>", "!=", "//=?", "->", "[+\\-*/%&|^=<>]=?", "~");
var Bracket = '[\\][(){}]';
var Special = group('\\r?\\n', '[:;.,`@]');
var Funny = group(Operator, Bracket, Special);
var ContStr = group("[uUbB]?[rR]?'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*" +
    group("'", '\\\\\\r?\\n'), '[uUbB]?[rR]?"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*' +
    group('"', '\\\\\\r?\\n'));
var PseudoExtras = group('\\\\\\r?\\n', Comment_, Triple);
// Need to prefix with "^" as we only want to match what's next
var PseudoToken = "^" + group(PseudoExtras, Number_, Funny, ContStr, Ident);
// let pseudoprog;
// let single3prog;
// let double3prog;
// const endprogs = {};
var triple_quoted = {
    "'''": true, '"""': true,
    "r'''": true, 'r"""': true, "R'''": true, 'R"""': true,
    "u'''": true, 'u"""': true, "U'''": true, 'U"""': true,
    "b'''": true, 'b"""': true, "B'''": true, 'B"""': true,
    "ur'''": true, 'ur"""': true, "Ur'''": true, 'Ur"""': true,
    "uR'''": true, 'uR"""': true, "UR'''": true, 'UR"""': true,
    "br'''": true, 'br"""': true, "Br'''": true, 'Br"""': true,
    "bR'''": true, 'bR"""': true, "BR'''": true, 'BR"""': true
};
var single_quoted = {
    "'": true, '"': true,
    "r'": true, 'r"': true, "R'": true, 'R"': true,
    "u'": true, 'u"': true, "U'": true, 'U"': true,
    "b'": true, 'b"': true, "B'": true, 'B"': true,
    "ur'": true, 'ur"': true, "Ur'": true, 'Ur"': true,
    "uR'": true, 'uR"': true, "UR'": true, 'UR"': true,
    "br'": true, 'br"': true, "Br'": true, 'Br"': true,
    "bR'": true, 'bR"': true, "BR'": true, 'BR"': true
};
var tabsize = 8;
/**
 * This is a port of tokenize.py by Ka-Ping Yee.
 *
 * each call to readline should return one line of input as a string, or
 * undefined if it's finished.
 *
 * callback is called for each token with 5 args:
 * 1. the token type
 * 2. the token string
 * 3. [ start_row, start_col ]
 * 4. [ end_row, end_col ]
 * 5. logical line where the token was found, including continuation lines
 *
 * callback can return true to abort.
 */
var Tokenizer = (function () {
    /**
     *
     */
    function Tokenizer(interactive, callback) {
        this.callback = callback;
        this.lnum = 0;
        this.parenlev = 0;
        this.continued = false;
        this.namechars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_';
        this.numchars = '0123456789';
        this.contstr = '';
        this.needcont = false;
        this.contline = undefined;
        this.indents = [0];
        this.endprog = /.*/;
        this.strstart = [-1, -1];
        this.interactive = interactive;
        this.doneFunc = function doneOrFailed() {
            for (var i = 1; i < this.indents.length; ++i) {
                if (this.callback(Tokens.T_DEDENT, '', [this.lnum, 0], [this.lnum, 0], ''))
                    return 'done';
            }
            if (this.callback(Tokens.T_ENDMARKER, '', [this.lnum, 0], [this.lnum, 0], ''))
                return 'done';
            return 'failed';
        };
    }
    /**
     * @param line
     * @return 'done' or 'failed' or true?
     */
    Tokenizer.prototype.generateTokens = function (line) {
        var endmatch;
        var pos;
        var column;
        var end;
        var max;
        // bnm - Move these definitions in this function otherwise test state is preserved between
        // calls on single3prog and double3prog causing weird errors with having multiple instances
        // of triple quoted strings in the same program.
        var pseudoprog = new RegExp(PseudoToken);
        var single3prog = new RegExp(Single3, "g");
        var double3prog = new RegExp(Double3, "g");
        var endprogs = {
            "'": new RegExp(Single, "g"), '"': new RegExp(Double_, "g"),
            "'''": single3prog, '"""': double3prog,
            "r'''": single3prog, 'r"""': double3prog,
            "u'''": single3prog, 'u"""': double3prog,
            "b'''": single3prog, 'b"""': double3prog,
            "ur'''": single3prog, 'ur"""': double3prog,
            "br'''": single3prog, 'br"""': double3prog,
            "R'''": single3prog, 'R"""': double3prog,
            "U'''": single3prog, 'U"""': double3prog,
            "B'''": single3prog, 'B"""': double3prog,
            "uR'''": single3prog, 'uR"""': double3prog,
            "Ur'''": single3prog, 'Ur"""': double3prog,
            "UR'''": single3prog, 'UR"""': double3prog,
            "bR'''": single3prog, 'bR"""': double3prog,
            "Br'''": single3prog, 'Br"""': double3prog,
            "BR'''": single3prog, 'BR"""': double3prog,
            'r': null, 'R': null,
            'u': null, 'U': null,
            'b': null, 'B': null
        };
        if (!line)
            line = '';
        this.lnum += 1;
        pos = 0;
        max = line.length;
        if (this.contstr.length > 0) {
            if (!line) {
                throw new TokenError("EOF in multi-line string", this.strstart[0], this.strstart[1]);
            }
            this.endprog.lastIndex = 0;
            endmatch = this.endprog.test(line);
            if (endmatch) {
                pos = end = this.endprog.lastIndex;
                if (this.callback(Tokens.T_STRING, this.contstr + line.substring(0, end), this.strstart, [this.lnum, end], this.contline + line))
                    return 'done';
                this.contstr = '';
                this.needcont = false;
                this.contline = undefined;
            }
            else if (this.needcont && line.substring(line.length - 2) !== "\\\n" && line.substring(line.length - 3) !== "\\\r\n") {
                if (this.callback(Tokens.T_ERRORTOKEN, this.contstr + line, this.strstart, [this.lnum, line.length], this.contline)) {
                    return 'done';
                }
                this.contstr = '';
                this.contline = undefined;
                return false;
            }
            else {
                this.contstr += line;
                this.contline = this.contline + line;
                return false;
            }
        }
        else if (this.parenlev === 0 && !this.continued) {
            if (!line)
                return this.doneFunc();
            column = 0;
            while (pos < max) {
                if (line.charAt(pos) === ' ')
                    column += 1;
                else if (line.charAt(pos) === '\t')
                    column = (column / tabsize + 1) * tabsize;
                else if (line.charAt(pos) === '\f')
                    column = 0;
                else
                    break;
                pos = pos + 1;
            }
            if (pos === max)
                return this.doneFunc();
            if ("#\r\n".indexOf(line.charAt(pos)) !== -1) {
                if (line.charAt(pos) === '#') {
                    var comment_token = rstrip(line.substring(pos), '\r\n');
                    var nl_pos = pos + comment_token.length;
                    if (this.callback(Tokens.T_COMMENT, comment_token, [this.lnum, pos], [this.lnum, pos + comment_token.length], line)) {
                        return 'done';
                    }
                    if (this.callback(Tokens.T_NL, line.substring(nl_pos), [this.lnum, nl_pos], [this.lnum, line.length], line)) {
                        return 'done';
                    }
                    return false;
                }
                else {
                    if (this.callback(Tokens.T_NL, line.substring(pos), [this.lnum, pos], [this.lnum, line.length], line))
                        return 'done';
                    if (!this.interactive)
                        return false;
                }
            }
            if (column > this.indents[this.indents.length - 1]) {
                this.indents.push(column);
                if (this.callback(Tokens.T_INDENT, line.substring(0, pos), [this.lnum, 0], [this.lnum, pos], line))
                    return 'done';
            }
            while (column < this.indents[this.indents.length - 1]) {
                if (!contains(this.indents, column)) {
                    throw indentationError("unindent does not match any outer indentation level", [this.lnum, 0], [this.lnum, pos], line);
                }
                this.indents.splice(this.indents.length - 1, 1);
                if (this.callback(Tokens.T_DEDENT, '', [this.lnum, pos], [this.lnum, pos], line)) {
                    return 'done';
                }
            }
        }
        else {
            if (!line) {
                throw new TokenError("EOF in multi-line statement", this.lnum, 0);
            }
            this.continued = false;
        }
        while (pos < max) {
            // js regexes don't return any info about matches, other than the
            // content. we'd like to put a \w+ before pseudomatch, but then we
            // can't get any data
            var capos = line.charAt(pos);
            while (capos === ' ' || capos === '\f' || capos === '\t') {
                pos += 1;
                capos = line.charAt(pos);
            }
            pseudoprog.lastIndex = 0;
            var pseudomatch = pseudoprog.exec(line.substring(pos));
            if (pseudomatch) {
                var start = pos;
                end = start + pseudomatch[1].length;
                var spos = [this.lnum, start];
                var epos = [this.lnum, end];
                pos = end;
                var token = line.substring(start, end);
                var initial = line.charAt(start);
                if (this.numchars.indexOf(initial) !== -1 || (initial === '.' && token !== '.')) {
                    if (this.callback(Tokens.T_NUMBER, token, spos, epos, line))
                        return 'done';
                }
                else if (initial === '\r' || initial === '\n') {
                    var newl = Tokens.T_NEWLINE;
                    if (this.parenlev > 0)
                        newl = Tokens.T_NL;
                    if (this.callback(newl, token, spos, epos, line))
                        return 'done';
                }
                else if (initial === '#') {
                    if (this.callback(Tokens.T_COMMENT, token, spos, epos, line))
                        return 'done';
                }
                else if (triple_quoted.hasOwnProperty(token)) {
                    this.endprog = endprogs[token];
                    this.endprog.lastIndex = 0;
                    endmatch = this.endprog.test(line.substring(pos));
                    if (endmatch) {
                        pos = this.endprog.lastIndex + pos;
                        var token_1 = line.substring(start, pos);
                        if (this.callback(Tokens.T_STRING, token_1, spos, [this.lnum, pos], line))
                            return 'done';
                    }
                    else {
                        this.strstart = [this.lnum, start];
                        this.contstr = line.substring(start);
                        this.contline = line;
                        return false;
                    }
                }
                else if (single_quoted.hasOwnProperty(initial) ||
                    single_quoted.hasOwnProperty(token.substring(0, 2)) ||
                    single_quoted.hasOwnProperty(token.substring(0, 3))) {
                    if (token[token.length - 1] === '\n') {
                        this.strstart = [this.lnum, start];
                        this.endprog = endprogs[initial] || endprogs[token[1]] || endprogs[token[2]];
                        this.contstr = line.substring(start);
                        this.needcont = true;
                        this.contline = line;
                        return false;
                    }
                    else {
                        if (this.callback(Tokens.T_STRING, token, spos, epos, line))
                            return 'done';
                    }
                }
                else if (this.namechars.indexOf(initial) !== -1) {
                    if (this.callback(Tokens.T_NAME, token, spos, epos, line))
                        return 'done';
                }
                else if (initial === '\\') {
                    if (this.callback(Tokens.T_NL, token, spos, [this.lnum, pos], line))
                        return 'done';
                    this.continued = true;
                }
                else {
                    if ('([{'.indexOf(initial) !== -1)
                        this.parenlev += 1;
                    else if (')]}'.indexOf(initial) !== -1)
                        this.parenlev -= 1;
                    if (this.callback(Tokens.T_OP, token, spos, epos, line))
                        return 'done';
                }
            }
            else {
                if (this.callback(Tokens.T_ERRORTOKEN, line.charAt(pos), [this.lnum, pos], [this.lnum, pos + 1], line))
                    return 'done';
                pos += 1;
            }
        }
        return false;
    };
    return Tokenizer;
}());
/** @param {...*} x */
function group(x, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
    var args = Array.prototype.slice.call(arguments);
    return '(' + args.join('|') + ')';
}
/** @param {...*} x */
// function any(x) { return group.apply(null, arguments) + "*"; }
/** @param {...*} x */
function maybe(x) { return group.apply(null, arguments) + "?"; }
function contains(a, obj) {
    var i = a.length;
    while (i--) {
        if (a[i] === obj) {
            return true;
        }
    }
    return false;
}
function rstrip(input, what) {
    var i;
    for (i = input.length; i > 0; --i) {
        if (what.indexOf(input.charAt(i - 1)) === -1)
            break;
    }
    return input.substring(0, i);
}
/**
 * @param message
 * @param begin
 * @param end
 * @param {string|undefined} text
 */
function indentationError(message, begin, end, text) {
    if (!isArray(begin)) {
        throw new Error("begin must be Array.<number>");
    }
    if (!isArray(end)) {
        throw new Error("end must be Array.<number>");
    }
    var e = new SyntaxError(message /*, fileName*/);
    e.name = "IndentationError";
    if (isDef(begin)) {
        e['lineNumber'] = begin[0];
        e['columnNumber'] = begin[1];
    }
    return e;
}

/**
 * Decodes of the tokens
 */
var tokenNames = {};
tokenNames[Tokens.T_AMPER] = 'T_AMPER';
tokenNames[Tokens.T_AMPEREQUAL] = 'T_AMPEREQUAL';
tokenNames[Tokens.T_AT] = 'T_AT';
tokenNames[Tokens.T_BACKQUOTE] = 'T_BACKQUOTE';
tokenNames[Tokens.T_CIRCUMFLEX] = 'T_CIRCUMFLEX';
tokenNames[Tokens.T_CIRCUMFLEXEQUAL] = 'T_CIRCUMFLEXEQUAL';
tokenNames[Tokens.T_COLON] = 'T_COLON';
tokenNames[Tokens.T_COMMA] = 'T_COMMA';
tokenNames[Tokens.T_COMMENT] = 'T_COMMENT';
tokenNames[Tokens.T_DEDENT] = 'T_DEDENT';
tokenNames[Tokens.T_DOT] = 'T_DOT';
tokenNames[Tokens.T_DOUBLESLASH] = 'T_DOUBLESLASH';
tokenNames[Tokens.T_DOUBLESLASHEQUAL] = 'T_DOUBLESLASHEQUAL';
tokenNames[Tokens.T_DOUBLESTAR] = 'T_DOUBLESTAR';
tokenNames[Tokens.T_DOUBLESTAREQUAL] = 'T_DOUBLESTAREQUAL';
tokenNames[Tokens.T_ENDMARKER] = 'T_ENDMARKER';
tokenNames[Tokens.T_EQEQUAL] = 'T_EQEQUAL';
tokenNames[Tokens.T_EQUAL] = 'T_EQUAL';
tokenNames[Tokens.T_ERRORTOKEN] = 'T_ERRORTOKEN';
tokenNames[Tokens.T_GREATER] = 'T_GREATER';
tokenNames[Tokens.T_GREATEREQUAL] = 'T_GREATEREQUAL';
tokenNames[Tokens.T_INDENT] = 'T_INDENT';
tokenNames[Tokens.T_LBRACE] = 'T_LBRACE';
tokenNames[Tokens.T_LEFTSHIFT] = 'T_LEFTSHIFT';
tokenNames[Tokens.T_LEFTSHIFTEQUAL] = 'T_LEFTSHIFTEQUAL';
tokenNames[Tokens.T_LESS] = 'T_LESS';
tokenNames[Tokens.T_LESSEQUAL] = 'T_LESSEQUAL';
tokenNames[Tokens.T_LPAR] = 'T_LPAR';
tokenNames[Tokens.T_LSQB] = 'T_LSQB';
tokenNames[Tokens.T_MINEQUAL] = 'T_MINEQUAL';
tokenNames[Tokens.T_MINUS] = 'T_MINUS';
tokenNames[Tokens.T_N_TOKENS] = 'T_N_TOKENS';
tokenNames[Tokens.T_NAME] = 'T_NAME';
tokenNames[Tokens.T_NEWLINE] = 'T_NEWLINE';
tokenNames[Tokens.T_NL] = 'T_NL';
tokenNames[Tokens.T_NOTEQUAL] = 'T_NOTEQUAL';
tokenNames[Tokens.T_NT_OFFSET] = 'T_NT_OFFSET';
tokenNames[Tokens.T_NUMBER] = 'T_NUMBER';
tokenNames[Tokens.T_OP] = 'T_OP';
tokenNames[Tokens.T_PERCENT] = 'T_PERCENT';
tokenNames[Tokens.T_PERCENTEQUAL] = 'T_PERCENTEQUAL';
tokenNames[Tokens.T_PLUS] = 'T_PLUS';
tokenNames[Tokens.T_PLUSEQUAL] = 'T_PLUSEQUAL';
tokenNames[Tokens.T_RARROW] = 'T_RARROW';
tokenNames[Tokens.T_RBRACE] = 'T_RBRACE';
tokenNames[Tokens.T_RIGHTSHIFT] = 'T_RIGHTSHIFT';
tokenNames[Tokens.T_RPAR] = 'T_RPAR';
tokenNames[Tokens.T_RSQB] = 'T_RSQB';
tokenNames[Tokens.T_SEMI] = 'T_SEMI';
tokenNames[Tokens.T_SLASH] = 'T_SLASH';
tokenNames[Tokens.T_SLASHEQUAL] = 'T_SLASHEQUAL';
tokenNames[Tokens.T_STAR] = 'T_STAR';
tokenNames[Tokens.T_STAREQUAL] = 'T_STAREQUAL';
tokenNames[Tokens.T_STRING] = 'T_STRING';
tokenNames[Tokens.T_TILDE] = 'T_TILDE';
tokenNames[Tokens.T_VBAR] = 'T_VBAR';
tokenNames[Tokens.T_VBAREQUAL] = 'T_VBAREQUAL';

// low level parser to a concrete syntax tree, derived from cpython's lib2to3
/**
 * @param message
 * @param fileName
 * @param begin
 * @param end
 */
function parseError(message, begin, end) {
    var e = new SyntaxError(message);
    e.name = "ParseError";
    if (Array.isArray(begin)) {
        e['lineNumber'] = begin[0];
        e['columnNumber'] = begin[1];
    }
    return e;
}
// TODO: The parser does not report whitespace nodes.
// It would be nice if there were an ignoreWhitespace option.
var Parser = (function () {
    /**
     *
     */
    function Parser(grammar) {
        this.grammar = grammar;
        return this;
    }
    Parser.prototype.setup = function (start) {
        start = start || this.grammar.start;
        var newnode = {
            type: start,
            value: null,
            context: null,
            children: []
        };
        var stackentry = {
            dfa: this.grammar.dfas[start],
            state: 0,
            node: newnode
        };
        this.stack = [stackentry];
        this.used_names = {};
    };
    /**
     * Add a token; return true if we're done.
     * @param type
     * @param value
     * @param context [start, end, line]
     */
    Parser.prototype.addtoken = function (type, value, context) {
        var ilabel = this.classify(type, value, context);
        OUTERWHILE: while (true) {
            var tp = this.stack[this.stack.length - 1];
            var states = tp.dfa[0];
            var first = tp.dfa[1];
            var arcs = states[tp.state];
            // look for a state with this label
            for (var a = 0; a < arcs.length; ++a) {
                var i = arcs[a][0];
                var newstate = arcs[a][1];
                var t = this.grammar.labels[i][0];
                // var v = this.grammar.labels[i][1];
                if (ilabel === i) {
                    // look it up in the list of labels
                    assert(t < 256);
                    // shift a token; we're done with it
                    this.shift(type, value, newstate, context);
                    // pop while we are in an accept-only state
                    var state = newstate;
                    while (states[state].length === 1
                        && states[state][0][0] === 0
                        && states[state][0][1] === state) {
                        this.pop();
                        if (this.stack.length === 0) {
                            // done!
                            return true;
                        }
                        tp = this.stack[this.stack.length - 1];
                        state = tp.state;
                        states = tp.dfa[0];
                        first = tp.dfa[1];
                    }
                    // done with this token
                    return false;
                }
                else if (t >= 256) {
                    var itsdfa = this.grammar.dfas[t];
                    var itsfirst = itsdfa[1];
                    if (itsfirst.hasOwnProperty(ilabel)) {
                        // push a symbol
                        this.push(t, this.grammar.dfas[t], newstate, context);
                        continue OUTERWHILE;
                    }
                }
            }
            // TODO: What is the zeroth state? Does it have a symbolic name?
            if (existsTransition(arcs, [0, tp.state])) {
                // an accepting state, pop it and try something else
                this.pop();
                if (this.stack.length === 0) {
                    throw parseError("too much input");
                }
            }
            else {
                throw parseError("bad input", context[0], context[1]);
            }
        }
    };
    /**
     * turn a token into a label.
     * @param type
     * @param value
     * @param context [begin, end, line]
     */
    Parser.prototype.classify = function (type, value, context) {
        var ilabel;
        if (type === Tokens.T_NAME) {
            this.used_names[value] = true;
            if (this.grammar.keywords.hasOwnProperty(value)) {
                ilabel = this.grammar.keywords[value];
            }
            if (ilabel) {
                return ilabel;
            }
        }
        if (this.grammar.tokens.hasOwnProperty(type)) {
            ilabel = this.grammar.tokens[type];
        }
        if (!ilabel) {
            throw parseError("bad token", context[0], context[1]);
        }
        return ilabel;
    };
    // shift a token
    Parser.prototype.shift = function (type, value, newstate, context) {
        var dfa = this.stack[this.stack.length - 1].dfa;
        // var state = this.stack[this.stack.length - 1].state;
        var node = this.stack[this.stack.length - 1].node;
        var newnode = {
            type: type,
            value: value,
            lineno: context[0][0],
            col_offset: context[0][1],
            children: null
        };
        if (newnode && node.children) {
            node.children.push(newnode);
        }
        this.stack[this.stack.length - 1] = { dfa: dfa, state: newstate, node: node };
    };
    // push a nonterminal
    Parser.prototype.push = function (type, newdfa, newstate, context) {
        var dfa = this.stack[this.stack.length - 1].dfa;
        var node = this.stack[this.stack.length - 1].node;
        this.stack[this.stack.length - 1] = { dfa: dfa, state: newstate, node: node };
        var newnode = { type: type, value: null, lineno: context[0][0], col_offset: context[0][1], children: [] };
        this.stack.push({ dfa: newdfa, state: 0, node: newnode });
    };
    // pop a nonterminal
    Parser.prototype.pop = function () {
        var pop = this.stack.pop();
        if (pop) {
            var newnode = pop.node;
            if (newnode) {
                if (this.stack.length !== 0) {
                    var node = this.stack[this.stack.length - 1].node;
                    if (node.children) {
                        node.children.push(newnode);
                    }
                }
                else {
                    this.rootnode = newnode;
                    this.rootnode.used_names = this.used_names;
                }
            }
        }
    };
    return Parser;
}());
/**
 * Finds the specified
 * @param a An array of arrays where each element is an array of two integers.
 * @param obj An array containing two integers.
 */
function existsTransition(a, obj) {
    var i = a.length;
    while (i--) {
        if (a[i][0] === obj[0] && a[i][1] === obj[1]) {
            return true;
        }
    }
    return false;
}
/**
 * parser for interactive input. returns a function that should be called with
 * lines of input as they are entered. the function will return false
 * until the input is complete, when it will return the rootnode of the parse.
 *
 * @param style root of parse tree (optional)
 */
function makeParser(style) {
    if (style === undefined)
        style = "file_input";
    // FIXME: Would be nice to get this typing locked down.
    var p = new Parser(ParseTables);
    // TODO: Can we do this over the symbolic constants?
    if (style === "file_input") {
        p.setup(ParseTables.sym.file_input);
    }
    else {
        console.warn("TODO: makeParser(style = " + style + ")");
    }
    var lineno = 1;
    var column = 0;
    var prefix = "";
    var T_COMMENT = Tokens.T_COMMENT;
    var T_NL = Tokens.T_NL;
    var T_OP = Tokens.T_OP;
    var tokenizer = new Tokenizer(style === "single_input", function tokenizerCallback(type, value, start, end, line) {
        // var s_lineno = start[0];
        // var s_column = start[1];
        /*
        if (s_lineno !== lineno && s_column !== column)
        {
            // todo; update prefix and line/col
        }
        */
        if (type === T_COMMENT || type === T_NL) {
            prefix += value;
            lineno = end[0];
            column = end[1];
            if (value[value.length - 1] === "\n") {
                lineno += 1;
                column = 0;
            }
            return undefined;
        }
        if (type === T_OP) {
            type = OpMap[value];
        }
        if (p.addtoken(type, value, [start, end, line])) {
            return true;
        }
        return undefined;
    });
    return function parseFunc(line) {
        var ret = tokenizer.generateTokens(line);
        if (ret) {
            if (ret !== "done") {
                throw parseError("incomplete input");
            }
            return p.rootnode;
        }
        return false;
    };
}
function parse(input) {
    var parseFunc = makeParser();
    // input.endsWith("\n");
    // Why do we normalize the input in this manner?
    if (input.substr(IDXLAST(input), 1) !== "\n") {
        input += "\n";
    }
    // Splitting this ay will create a final line that is the zero-length string.
    var lines = input.split("\n");
    // FIXME: Mixing the types this way is awkward for the consumer.
    var ret = false;
    for (var i = 0; i < lines.length; ++i) {
        // FIXME: Lots of string creation going on here. Why?
        // We're adding back newline characters for all but the last line.
        ret = parseFunc(lines[i] + ((i === IDXLAST(lines)) ? "" : "\n"));
    }
    return ret;
}
function parseTreeDump(n) {
    var ret = "";
    // non-term
    if (n.type >= 256) {
        ret += ParseTables.number2symbol[n.type] + "\n";
        if (n.children) {
            for (var i = 0; i < n.children.length; ++i) {
                ret += parseTreeDump(n.children[i]);
            }
        }
    }
    else {
        ret += tokenNames[n.type] + ": " + n.value + "\n";
    }
    return ret;
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var Load = (function () {
    function Load() {
    }
    return Load;
}());
var Store = (function () {
    function Store() {
    }
    return Store;
}());
var Del = (function () {
    function Del() {
    }
    return Del;
}());
var AugLoad = (function () {
    function AugLoad() {
    }
    return AugLoad;
}());
var AugStore = (function () {
    function AugStore() {
    }
    return AugStore;
}());
var Param = (function () {
    function Param() {
    }
    return Param;
}());
var And = (function () {
    function And() {
    }
    return And;
}());
var Or = (function () {
    function Or() {
    }
    return Or;
}());
var Add = (function () {
    function Add() {
    }
    return Add;
}());
var Sub = (function () {
    function Sub() {
    }
    return Sub;
}());
var Mult = (function () {
    function Mult() {
    }
    return Mult;
}());
var Div = (function () {
    function Div() {
    }
    return Div;
}());
var Mod = (function () {
    function Mod() {
    }
    return Mod;
}());
var Pow = (function () {
    function Pow() {
    }
    return Pow;
}());
var LShift = (function () {
    function LShift() {
    }
    return LShift;
}());
var RShift = (function () {
    function RShift() {
    }
    return RShift;
}());
var BitOr = (function () {
    function BitOr() {
    }
    return BitOr;
}());
var BitXor = (function () {
    function BitXor() {
    }
    return BitXor;
}());
var BitAnd = (function () {
    function BitAnd() {
    }
    return BitAnd;
}());
var FloorDiv = (function () {
    function FloorDiv() {
    }
    return FloorDiv;
}());
var Invert = (function () {
    function Invert() {
    }
    return Invert;
}());
var Not = (function () {
    function Not() {
    }
    return Not;
}());
var UAdd = (function () {
    function UAdd() {
    }
    return UAdd;
}());
var USub = (function () {
    function USub() {
    }
    return USub;
}());
var Eq = (function () {
    function Eq() {
    }
    return Eq;
}());
var NotEq = (function () {
    function NotEq() {
    }
    return NotEq;
}());
var Lt = (function () {
    function Lt() {
    }
    return Lt;
}());
var LtE = (function () {
    function LtE() {
    }
    return LtE;
}());
var Gt = (function () {
    function Gt() {
    }
    return Gt;
}());
var GtE = (function () {
    function GtE() {
    }
    return GtE;
}());
var Is = (function () {
    function Is() {
    }
    return Is;
}());
var IsNot = (function () {
    function IsNot() {
    }
    return IsNot;
}());
var In = (function () {
    function In() {
    }
    return In;
}());
var NotIn = (function () {
    function NotIn() {
    }
    return NotIn;
}());
var ASTSpan = (function () {
    function ASTSpan() {
        this.minChar = -1; // -1 = "undefined" or "compiler generated"
        this.limChar = -1; // -1 = "undefined" or "compiler generated"
    }
    return ASTSpan;
}());
var AST = (function (_super) {
    __extends(AST, _super);
    function AST() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return AST;
}(ASTSpan));
var ModuleElement = (function (_super) {
    __extends(ModuleElement, _super);
    function ModuleElement() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ModuleElement;
}(AST));
var Statement = (function (_super) {
    __extends(Statement, _super);
    function Statement() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Statement;
}(ModuleElement));
var IterationStatement = (function (_super) {
    __extends(IterationStatement, _super);
    function IterationStatement() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return IterationStatement;
}(Statement));
var Module = (function () {
    function Module(body) {
        this.body = body;
    }
    return Module;
}());
var Interactive = (function () {
    function Interactive(body) {
        this.body = body;
    }
    return Interactive;
}());
var Expression = (function (_super) {
    __extends(Expression, _super);
    function Expression(body) {
        var _this = _super.call(this) || this;
        _this.body = body;
        return _this;
    }
    return Expression;
}(Statement));
var UnaryExpression = (function (_super) {
    __extends(UnaryExpression, _super);
    function UnaryExpression() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return UnaryExpression;
}(Expression));
var Suite = (function () {
    function Suite(body) {
        this.body = body;
    }
    return Suite;
}());
var FunctionDef = (function (_super) {
    __extends(FunctionDef, _super);
    function FunctionDef(name, args, body, decorator_list, lineno, col_offset) {
        var _this = _super.call(this) || this;
        _this.name = name;
        _this.args = args;
        _this.body = body;
        _this.decorator_list = decorator_list;
        _this.lineno = lineno;
        _this.col_offset = col_offset;
        return _this;
    }
    return FunctionDef;
}(Statement));
var ClassDef = (function (_super) {
    __extends(ClassDef, _super);
    function ClassDef(name, bases, body, decorator_list, lineno, col_offset) {
        var _this = _super.call(this) || this;
        _this.name = name;
        _this.bases = bases;
        _this.body = body;
        _this.decorator_list = decorator_list;
        _this.lineno = lineno;
        _this.col_offset = col_offset;
        return _this;
    }
    return ClassDef;
}(Statement));
var ReturnStatement = (function (_super) {
    __extends(ReturnStatement, _super);
    function ReturnStatement(value, lineno, col_offset) {
        var _this = _super.call(this) || this;
        _this.value = value;
        _this.lineno = lineno;
        _this.col_offset = col_offset;
        return _this;
    }
    return ReturnStatement;
}(Statement));
var DeleteExpression = (function (_super) {
    __extends(DeleteExpression, _super);
    function DeleteExpression(targets, lineno, col_offset) {
        var _this = _super.call(this, targets) || this;
        _this.targets = targets;
        _this.lineno = lineno;
        _this.col_offset = col_offset;
        return _this;
    }
    return DeleteExpression;
}(UnaryExpression));
var Assign = (function (_super) {
    __extends(Assign, _super);
    function Assign(targets, value, lineno, col_offset) {
        var _this = _super.call(this) || this;
        _this.targets = targets;
        _this.value = value;
        _this.lineno = lineno;
        _this.col_offset = col_offset;
        return _this;
    }
    return Assign;
}(Statement));
var AugAssign = (function (_super) {
    __extends(AugAssign, _super);
    function AugAssign(target, op, value, lineno, col_offset) {
        var _this = _super.call(this) || this;
        _this.target = target;
        _this.op = op;
        _this.value = value;
        _this.lineno = lineno;
        _this.col_offset = col_offset;
        return _this;
    }
    return AugAssign;
}(Statement));
var Print = (function (_super) {
    __extends(Print, _super);
    function Print(dest, values, nl, lineno, col_offset) {
        var _this = _super.call(this) || this;
        _this.dest = dest;
        _this.values = values;
        _this.nl = nl;
        _this.lineno = lineno;
        _this.col_offset = col_offset;
        return _this;
    }
    return Print;
}(Statement));
var ForStatement = (function (_super) {
    __extends(ForStatement, _super);
    function ForStatement(target, iter, body, orelse, lineno, col_offset) {
        var _this = _super.call(this) || this;
        _this.target = target;
        _this.iter = iter;
        _this.body = body;
        _this.orelse = orelse;
        _this.lineno = lineno;
        _this.col_offset = col_offset;
        return _this;
    }
    return ForStatement;
}(IterationStatement));
var WhileStatement = (function (_super) {
    __extends(WhileStatement, _super);
    function WhileStatement(test, body, orelse, lineno, col_offset) {
        var _this = _super.call(this) || this;
        _this.test = test;
        _this.body = body;
        _this.orelse = orelse;
        _this.lineno = lineno;
        _this.col_offset = col_offset;
        return _this;
    }
    return WhileStatement;
}(IterationStatement));
var IfStatement = (function (_super) {
    __extends(IfStatement, _super);
    function IfStatement(test, consequent, alternate, lineno, col_offset) {
        var _this = _super.call(this) || this;
        _this.test = test;
        _this.consequent = consequent;
        _this.alternate = alternate;
        _this.lineno = lineno;
        _this.col_offset = col_offset;
        return _this;
    }
    return IfStatement;
}(Statement));
var WithStatement = (function (_super) {
    __extends(WithStatement, _super);
    function WithStatement(context_expr, optional_vars, body, lineno, col_offset) {
        var _this = _super.call(this) || this;
        _this.context_expr = context_expr;
        _this.optional_vars = optional_vars;
        _this.body = body;
        _this.lineno = lineno;
        _this.col_offset = col_offset;
        return _this;
    }
    return WithStatement;
}(Statement));
var Raise = (function (_super) {
    __extends(Raise, _super);
    function Raise(type, inst, tback, lineno, col_offset) {
        var _this = _super.call(this) || this;
        _this.type = type;
        _this.inst = inst;
        _this.tback = tback;
        _this.lineno = lineno;
        _this.col_offset = col_offset;
        return _this;
    }
    return Raise;
}(Statement));
var TryExcept = (function (_super) {
    __extends(TryExcept, _super);
    function TryExcept(body, handlers, orelse, lineno, col_offset) {
        var _this = _super.call(this) || this;
        _this.body = body;
        _this.handlers = handlers;
        _this.orelse = orelse;
        _this.lineno = lineno;
        _this.col_offset = col_offset;
        return _this;
    }
    return TryExcept;
}(Statement));
var TryFinally = (function (_super) {
    __extends(TryFinally, _super);
    function TryFinally(body, finalbody, lineno, col_offset) {
        var _this = _super.call(this) || this;
        _this.body = body;
        _this.finalbody = finalbody;
        _this.lineno = lineno;
        _this.col_offset = col_offset;
        return _this;
    }
    return TryFinally;
}(Statement));
var Assert = (function (_super) {
    __extends(Assert, _super);
    function Assert(test, msg, lineno, col_offset) {
        var _this = _super.call(this) || this;
        _this.test = test;
        _this.msg = msg;
        _this.lineno = lineno;
        _this.col_offset = col_offset;
        return _this;
    }
    return Assert;
}(Statement));
var ImportStatement = (function (_super) {
    __extends(ImportStatement, _super);
    function ImportStatement(names, lineno, col_offset) {
        var _this = _super.call(this) || this;
        _this.names = names;
        _this.lineno = lineno;
        _this.col_offset = col_offset;
        return _this;
    }
    return ImportStatement;
}(Statement));
var ImportFrom = (function (_super) {
    __extends(ImportFrom, _super);
    function ImportFrom(module, names, level, lineno, col_offset) {
        var _this = _super.call(this) || this;
        _this.module = module;
        _this.names = names;
        _this.level = level;
        _this.lineno = lineno;
        _this.col_offset = col_offset;
        return _this;
    }
    return ImportFrom;
}(Statement));
var Exec = (function () {
    function Exec(body, globals, locals, lineno, col_offset) {
        this.body = body;
        this.globals = globals;
        this.locals = locals;
        this.lineno = lineno;
        this.col_offset = col_offset;
    }
    return Exec;
}());
var Global = (function () {
    function Global(names, lineno, col_offset) {
        this.names = names;
        this.lineno = lineno;
        this.col_offset = col_offset;
    }
    return Global;
}());
var NonLocal = (function () {
    function NonLocal(names, lineno, col_offset) {
        this.names = names;
        this.lineno = lineno;
        this.col_offset = col_offset;
    }
    return NonLocal;
}());
var Expr = (function (_super) {
    __extends(Expr, _super);
    function Expr(value, lineno, col_offset) {
        var _this = _super.call(this) || this;
        _this.value = value;
        _this.lineno = lineno;
        _this.col_offset = col_offset;
        return _this;
    }
    return Expr;
}(Statement));
var Pass = (function () {
    function Pass(lineno, col_offset) {
        this.lineno = lineno;
        this.col_offset = col_offset;
    }
    return Pass;
}());
var BreakStatement = (function (_super) {
    __extends(BreakStatement, _super);
    function BreakStatement(lineno, col_offset) {
        var _this = _super.call(this) || this;
        _this.lineno = lineno;
        _this.col_offset = col_offset;
        return _this;
    }
    return BreakStatement;
}(Statement));
var ContinueStatement = (function (_super) {
    __extends(ContinueStatement, _super);
    function ContinueStatement(lineno, col_offset) {
        var _this = _super.call(this) || this;
        _this.lineno = lineno;
        _this.col_offset = col_offset;
        return _this;
    }
    return ContinueStatement;
}(Statement));
var BoolOp = (function () {
    function BoolOp(op, values, lineno, col_offset) {
        this.op = op;
        this.values = values;
        this.lineno = lineno;
        this.col_offset = col_offset;
    }
    return BoolOp;
}());
var BinOp = (function () {
    function BinOp(left, op, right, lineno, col_offset) {
        this.left = left;
        this.op = op;
        this.right = right;
        this.lineno = lineno;
        this.col_offset = col_offset;
    }
    return BinOp;
}());
var UnaryOp = (function () {
    function UnaryOp(op, operand, lineno, col_offset) {
        this.op = op;
        this.operand = operand;
        this.lineno = lineno;
        this.col_offset = col_offset;
    }
    return UnaryOp;
}());
var Lambda = (function () {
    function Lambda(args, body, lineno, col_offset) {
        this.args = args;
        this.body = body;
        this.lineno = lineno;
        this.col_offset = col_offset;
    }
    return Lambda;
}());
var IfExp = (function () {
    function IfExp(test, body, orelse, lineno, col_offset) {
        this.test = test;
        this.body = body;
        this.orelse = orelse;
        this.lineno = lineno;
        this.col_offset = col_offset;
    }
    return IfExp;
}());
var Dict = (function () {
    function Dict(keys, values, lineno, col_offset) {
        this.keys = keys;
        this.values = values;
        this.lineno = lineno;
        this.col_offset = col_offset;
    }
    return Dict;
}());
var ListComp = (function () {
    function ListComp(elt, generators, lineno, col_offset) {
        this.elt = elt;
        this.generators = generators;
        this.lineno = lineno;
        this.col_offset = col_offset;
    }
    return ListComp;
}());
var GeneratorExp = (function () {
    function GeneratorExp(elt, generators, lineno, col_offset) {
        this.elt = elt;
        this.generators = generators;
        this.lineno = lineno;
        this.col_offset = col_offset;
    }
    return GeneratorExp;
}());
var Yield = (function () {
    function Yield(value, lineno, col_offset) {
        this.value = value;
        this.lineno = lineno;
        this.col_offset = col_offset;
    }
    return Yield;
}());
var Compare = (function () {
    function Compare(left, ops, comparators, lineno, col_offset) {
        this.left = left;
        this.ops = ops;
        this.comparators = comparators;
        this.lineno = lineno;
        this.col_offset = col_offset;
    }
    return Compare;
}());
var Call = (function () {
    function Call(func, args, keywords, starargs, kwargs, lineno, col_offset) {
        this.func = func;
        this.args = args;
        this.keywords = keywords;
        this.starargs = starargs;
        this.kwargs = kwargs;
        this.lineno = lineno;
        this.col_offset = col_offset;
    }
    return Call;
}());
var Num = (function () {
    function Num(n, lineno, col_offset) {
        this.n = n;
        this.lineno = lineno;
        this.col_offset = col_offset;
    }
    return Num;
}());
var Str = (function () {
    function Str(s, lineno, col_offset) {
        this.s = s;
        this.lineno = lineno;
        this.col_offset = col_offset;
    }
    return Str;
}());
var Attribute = (function () {
    function Attribute(value, attr, ctx, lineno, col_offset) {
        this.value = value;
        this.attr = attr;
        this.ctx = ctx;
        this.lineno = lineno;
        this.col_offset = col_offset;
    }
    return Attribute;
}());
var Subscript = (function () {
    function Subscript(value, slice, ctx, lineno, col_offset) {
        this.value = value;
        this.slice = slice;
        this.ctx = ctx;
        this.lineno = lineno;
        this.col_offset = col_offset;
    }
    return Subscript;
}());
var Name = (function (_super) {
    __extends(Name, _super);
    function Name(id, ctx, lineno, col_offset) {
        var _this = _super.call(this, void 0) || this;
        _this.id = id;
        _this.ctx = ctx;
        _this.lineno = lineno;
        _this.col_offset = col_offset;
        return _this;
    }
    return Name;
}(Expression));
var List = (function () {
    function List(elts, ctx, lineno, col_offset) {
        this.elts = elts;
        this.ctx = ctx;
        this.lineno = lineno;
        this.col_offset = col_offset;
    }
    return List;
}());
var Tuple = (function () {
    function Tuple(elts, ctx, lineno, col_offset) {
        this.elts = elts;
        this.ctx = ctx;
        this.lineno = lineno;
        this.col_offset = col_offset;
    }
    return Tuple;
}());
var Ellipsis = (function () {
    function Ellipsis() {
        // Do nothing yet.
    }
    return Ellipsis;
}());
var Slice = (function () {
    function Slice(lower, upper, step) {
        this.lower = lower;
        this.upper = upper;
        this.step = step;
    }
    return Slice;
}());
var ExtSlice = (function () {
    function ExtSlice(dims) {
        this.dims = dims;
    }
    return ExtSlice;
}());
var Index = (function () {
    function Index(value) {
        this.value = value;
    }
    return Index;
}());
var Comprehension = (function () {
    function Comprehension(target, iter, ifs) {
        this.target = target;
        this.iter = iter;
        this.ifs = ifs;
    }
    return Comprehension;
}());
var ExceptHandler = (function () {
    function ExceptHandler(type, name, body, lineno, col_offset) {
        this.type = type;
        this.name = name;
        this.body = body;
        this.lineno = lineno;
        this.col_offset = col_offset;
    }
    return ExceptHandler;
}());
var Arguments = (function () {
    function Arguments(args, vararg, kwarg, defaults) {
        this.args = args;
        this.vararg = vararg;
        this.kwarg = kwarg;
        this.defaults = defaults;
    }
    return Arguments;
}());
var Keyword = (function () {
    function Keyword(arg, value) {
        this.arg = arg;
        this.value = value;
    }
    return Keyword;
}());
var Alias = (function () {
    function Alias(name, asname) {
        this.name = name;
        this.asname = asname;
    }
    return Alias;
}());
Module.prototype['_astname'] = 'Module';
Module.prototype['_fields'] = [
    'body', function (n) { return n.body; }
];
Interactive.prototype['_astname'] = 'Interactive';
Interactive.prototype['_fields'] = [
    'body', function (n) { return n.body; }
];
Expression.prototype['_astname'] = 'Expression';
Expression.prototype['_fields'] = [
    'body', function (n) { return n.body; }
];
Suite.prototype['_astname'] = 'Suite';
Suite.prototype['_fields'] = [
    'body', function (n) { return n.body; }
];
FunctionDef.prototype['_astname'] = 'FunctionDef';
FunctionDef.prototype['_fields'] = [
    'name', function (n) { return n.name; },
    'args', function (n) { return n.args; },
    'body', function (n) { return n.body; },
    'decorator_list', function (n) { return n.decorator_list; }
];
ClassDef.prototype['_astname'] = 'ClassDef';
ClassDef.prototype['_fields'] = [
    'name', function (n) { return n.name; },
    'bases', function (n) { return n.bases; },
    'body', function (n) { return n.body; },
    'decorator_list', function (n) { return n.decorator_list; }
];
ReturnStatement.prototype['_astname'] = 'ReturnStatement';
ReturnStatement.prototype['_fields'] = [
    'value', function (n) { return n.value; }
];
DeleteExpression.prototype['_astname'] = 'Delete';
DeleteExpression.prototype['_fields'] = [
    'targets', function (n) { return n.targets; }
];
Assign.prototype['_astname'] = 'Assign';
Assign.prototype['_fields'] = [
    'targets', function (n) { return n.targets; },
    'value', function (n) { return n.value; }
];
AugAssign.prototype['_astname'] = 'AugAssign';
AugAssign.prototype['_fields'] = [
    'target', function (n) { return n.target; },
    'op', function (n) { return n.op; },
    'value', function (n) { return n.value; }
];
Print.prototype['_astname'] = 'Print';
Print.prototype['_fields'] = [
    'dest', function (n) { return n.dest; },
    'values', function (n) { return n.values; },
    'nl', function (n) { return n.nl; }
];
ForStatement.prototype['_astname'] = 'ForStatement';
ForStatement.prototype['_fields'] = [
    'target', function (n) { return n.target; },
    'iter', function (n) { return n.iter; },
    'body', function (n) { return n.body; },
    'orelse', function (n) { return n.orelse; }
];
WhileStatement.prototype['_astname'] = 'WhileStatement';
WhileStatement.prototype['_fields'] = [
    'test', function (n) { return n.test; },
    'body', function (n) { return n.body; },
    'orelse', function (n) { return n.orelse; }
];
IfStatement.prototype['_astname'] = 'IfStatement';
IfStatement.prototype['_fields'] = [
    'test', function (n) { return n.test; },
    'consequent', function (n) { return n.consequent; },
    'alternate', function (n) { return n.alternate; }
];
WithStatement.prototype['_astname'] = 'WithStatement';
WithStatement.prototype['_fields'] = [
    'context_expr', function (n) { return n.context_expr; },
    'optional_vars', function (n) { return n.optional_vars; },
    'body', function (n) { return n.body; }
];
Raise.prototype['_astname'] = 'Raise';
Raise.prototype['_fields'] = [
    'type', function (n) { return n.type; },
    'inst', function (n) { return n.inst; },
    'tback', function (n) { return n.tback; }
];
TryExcept.prototype['_astname'] = 'TryExcept';
TryExcept.prototype['_fields'] = [
    'body', function (n) { return n.body; },
    'handlers', function (n) { return n.handlers; },
    'orelse', function (n) { return n.orelse; }
];
TryFinally.prototype['_astname'] = 'TryFinally';
TryFinally.prototype['_fields'] = [
    'body', function (n) { return n.body; },
    'finalbody', function (n) { return n.finalbody; }
];
Assert.prototype['_astname'] = 'Assert';
Assert.prototype['_fields'] = [
    'test', function (n) { return n.test; },
    'msg', function (n) { return n.msg; }
];
ImportStatement.prototype['_astname'] = 'Import';
ImportStatement.prototype['_fields'] = [
    'names', function (n) { return n.names; }
];
ImportFrom.prototype['_astname'] = 'ImportFrom';
ImportFrom.prototype['_fields'] = [
    'module', function (n) { return n.module; },
    'names', function (n) { return n.names; },
    'level', function (n) { return n.level; }
];
Exec.prototype['_astname'] = 'Exec';
Exec.prototype['_fields'] = [
    'body', function (n) { return n.body; },
    'globals', function (n) { return n.globals; },
    'locals', function (n) { return n.locals; }
];
Global.prototype['_astname'] = 'Global';
Global.prototype['_fields'] = [
    'names', function (n) { return n.names; }
];
NonLocal.prototype['_astname'] = 'NonLocal';
NonLocal.prototype['_fields'] = [
    'names', function (n) { return n.names; }
];
Expr.prototype['_astname'] = 'Expr';
Expr.prototype['_fields'] = [
    'value', function (n) { return n.value; }
];
Pass.prototype['_astname'] = 'Pass';
Pass.prototype['_fields'] = [];
BreakStatement.prototype['_astname'] = 'BreakStatement';
BreakStatement.prototype['_fields'] = [];
ContinueStatement.prototype['_astname'] = 'ContinueStatement';
ContinueStatement.prototype['_fields'] = [];
BoolOp.prototype['_astname'] = 'BoolOp';
BoolOp.prototype['_fields'] = [
    'op', function (n) { return n.op; },
    'values', function (n) { return n.values; }
];
BinOp.prototype['_astname'] = 'BinOp';
BinOp.prototype['_fields'] = [
    'left', function (n) { return n.left; },
    'op', function (n) { return n.op; },
    'right', function (n) { return n.right; }
];
UnaryOp.prototype['_astname'] = 'UnaryOp';
UnaryOp.prototype['_fields'] = [
    'op', function (n) { return n.op; },
    'operand', function (n) { return n.operand; }
];
Lambda.prototype['_astname'] = 'Lambda';
Lambda.prototype['_fields'] = [
    'args', function (n) { return n.args; },
    'body', function (n) { return n.body; }
];
IfExp.prototype['_astname'] = 'IfExp';
IfExp.prototype['_fields'] = [
    'test', function (n) { return n.test; },
    'body', function (n) { return n.body; },
    'orelse', function (n) { return n.orelse; }
];
Dict.prototype['_astname'] = 'Dict';
Dict.prototype['_fields'] = [
    'keys', function (n) { return n.keys; },
    'values', function (n) { return n.values; }
];
ListComp.prototype['_astname'] = 'ListComp';
ListComp.prototype['_fields'] = [
    'elt', function (n) { return n.elt; },
    'generators', function (n) { return n.generators; }
];
GeneratorExp.prototype['_astname'] = 'GeneratorExp';
GeneratorExp.prototype['_fields'] = [
    'elt', function (n) { return n.elt; },
    'generators', function (n) { return n.generators; }
];
Yield.prototype['_astname'] = 'Yield';
Yield.prototype['_fields'] = [
    'value', function (n) { return n.value; }
];
Compare.prototype['_astname'] = 'Compare';
Compare.prototype['_fields'] = [
    'left', function (n) { return n.left; },
    'ops', function (n) { return n.ops; },
    'comparators', function (n) { return n.comparators; }
];
Call.prototype['_astname'] = 'Call';
Call.prototype['_fields'] = [
    'func', function (n) { return n.func; },
    'args', function (n) { return n.args; },
    'keywords', function (n) { return n.keywords; },
    'starargs', function (n) { return n.starargs; },
    'kwargs', function (n) { return n.kwargs; }
];
Num.prototype['_astname'] = 'Num';
Num.prototype['_fields'] = [
    'n', function (n) { return n.n; }
];
Str.prototype['_astname'] = 'Str';
Str.prototype['_fields'] = [
    's', function (n) { return n.s; }
];
Attribute.prototype['_astname'] = 'Attribute';
Attribute.prototype['_fields'] = [
    'value', function (n) { return n.value; },
    'attr', function (n) { return n.attr; },
    'ctx', function (n) { return n.ctx; }
];
Subscript.prototype['_astname'] = 'Subscript';
Subscript.prototype['_fields'] = [
    'value', function (n) { return n.value; },
    'slice', function (n) { return n.slice; },
    'ctx', function (n) { return n.ctx; }
];
Name.prototype['_astname'] = 'Name';
Name.prototype['_fields'] = [
    'id', function (n) { return n.id; },
    'ctx', function (n) { return n.ctx; }
];
List.prototype['_astname'] = 'List';
List.prototype['_fields'] = [
    'elts', function (n) { return n.elts; },
    'ctx', function (n) { return n.ctx; }
];
Tuple.prototype['_astname'] = 'Tuple';
Tuple.prototype['_fields'] = [
    'elts', function (n) { return n.elts; },
    'ctx', function (n) { return n.ctx; }
];
Load.prototype['_astname'] = 'Load';
Load.prototype['_isenum'] = true;
Store.prototype['_astname'] = 'Store';
Store.prototype['_isenum'] = true;
Del.prototype['_astname'] = 'Del';
Del.prototype['_isenum'] = true;
AugLoad.prototype['_astname'] = 'AugLoad';
AugLoad.prototype['_isenum'] = true;
AugStore.prototype['_astname'] = 'AugStore';
AugStore.prototype['_isenum'] = true;
Param.prototype['_astname'] = 'Param';
Param.prototype['_isenum'] = true;
Ellipsis.prototype['_astname'] = 'Ellipsis';
Ellipsis.prototype['_fields'] = [];
Slice.prototype['_astname'] = 'Slice';
Slice.prototype['_fields'] = [
    'lower', function (n) { return n.lower; },
    'upper', function (n) { return n.upper; },
    'step', function (n) { return n.step; }
];
ExtSlice.prototype['_astname'] = 'ExtSlice';
ExtSlice.prototype['_fields'] = [
    'dims', function (n) { return n.dims; }
];
Index.prototype['_astname'] = 'Index';
Index.prototype['_fields'] = [
    'value', function (n) { return n.value; }
];
And.prototype['_astname'] = 'And';
And.prototype['_isenum'] = true;
Or.prototype['_astname'] = 'Or';
Or.prototype['_isenum'] = true;
Add.prototype['_astname'] = 'Add';
Add.prototype['_isenum'] = true;
Sub.prototype['_astname'] = 'Sub';
Sub.prototype['_isenum'] = true;
Mult.prototype['_astname'] = 'Mult';
Mult.prototype['_isenum'] = true;
Div.prototype['_astname'] = 'Div';
Div.prototype['_isenum'] = true;
Mod.prototype['_astname'] = 'Mod';
Mod.prototype['_isenum'] = true;
Pow.prototype['_astname'] = 'Pow';
Pow.prototype['_isenum'] = true;
LShift.prototype['_astname'] = 'LShift';
LShift.prototype['_isenum'] = true;
RShift.prototype['_astname'] = 'RShift';
RShift.prototype['_isenum'] = true;
BitOr.prototype['_astname'] = 'BitOr';
BitOr.prototype['_isenum'] = true;
BitXor.prototype['_astname'] = 'BitXor';
BitXor.prototype['_isenum'] = true;
BitAnd.prototype['_astname'] = 'BitAnd';
BitAnd.prototype['_isenum'] = true;
FloorDiv.prototype['_astname'] = 'FloorDiv';
FloorDiv.prototype['_isenum'] = true;
Invert.prototype['_astname'] = 'Invert';
Invert.prototype['_isenum'] = true;
Not.prototype['_astname'] = 'Not';
Not.prototype['_isenum'] = true;
UAdd.prototype['_astname'] = 'UAdd';
UAdd.prototype['_isenum'] = true;
USub.prototype['_astname'] = 'USub';
USub.prototype['_isenum'] = true;
Eq.prototype['_astname'] = 'Eq';
Eq.prototype['_isenum'] = true;
NotEq.prototype['_astname'] = 'NotEq';
NotEq.prototype['_isenum'] = true;
Lt.prototype['_astname'] = 'Lt';
Lt.prototype['_isenum'] = true;
LtE.prototype['_astname'] = 'LtE';
LtE.prototype['_isenum'] = true;
Gt.prototype['_astname'] = 'Gt';
Gt.prototype['_isenum'] = true;
GtE.prototype['_astname'] = 'GtE';
GtE.prototype['_isenum'] = true;
Is.prototype['_astname'] = 'Is';
Is.prototype['_isenum'] = true;
IsNot.prototype['_astname'] = 'IsNot';
IsNot.prototype['_isenum'] = true;
In.prototype['_astname'] = 'In';
In.prototype['_isenum'] = true;
NotIn.prototype['_astname'] = 'NotIn';
NotIn.prototype['_isenum'] = true;
Comprehension.prototype['_astname'] = 'Comprehension';
Comprehension.prototype['_fields'] = [
    'target', function (n) { return n.target; },
    'iter', function (n) { return n.iter; },
    'ifs', function (n) { return n.ifs; }
];
ExceptHandler.prototype['_astname'] = 'ExceptHandler';
ExceptHandler.prototype['_fields'] = [
    'type', function (n) { return n.type; },
    'name', function (n) { return n.name; },
    'body', function (n) { return n.body; }
];
Arguments.prototype['_astname'] = 'Arguments';
Arguments.prototype['_fields'] = [
    'args', function (n) { return n.args; },
    'vararg', function (n) { return n.vararg; },
    'kwarg', function (n) { return n.kwarg; },
    'defaults', function (n) { return n.defaults; }
];
Keyword.prototype['_astname'] = 'Keyword';
Keyword.prototype['_fields'] = [
    'arg', function (n) { return n.arg; },
    'value', function (n) { return n.value; }
];
Alias.prototype['_astname'] = 'Alias';
Alias.prototype['_fields'] = [
    'name', function (n) { return n.name; },
    'asname', function (n) { return n.asname; }
];

/**
 * @param s
 */
function floatAST(s) {
    var thing = {
        text: s,
        value: parseFloat(s),
        isFloat: function () { return true; },
        isInt: function () { return false; },
        isLong: function () { return false; },
        toString: function () { return s; }
    };
    return thing;
}
/**
 * @param n
 */
function intAST(n) {
    var thing = {
        value: n,
        isFloat: function () { return false; },
        isInt: function () { return true; },
        isLong: function () { return false; },
        toString: function () { return '' + n; }
    };
    return thing;
}
/**
 * @param {string} s
 */
function longAST(s, radix) {
    var thing = {
        text: s,
        radix: radix,
        isFloat: function () { return false; },
        isInt: function () { return false; },
        isLong: function () { return true; },
        toString: function () { return s; }
    };
    return thing;
}

// TODO: Conventions
// FIXME: Convention
//
// This is pretty much a straight port of ast.c from CPython 2.6.5.
//
// The previous version was easier to work with and more JS-ish, but having a
// somewhat different ast structure than cpython makes testing more difficult.
//
// This way, we can use a dump from the ast module on any arbitrary python
// code and know that we're the same up to ast level, at least.
//
var SYM = ParseTables.sym;
/**
 *
 */
var LONG_THRESHOLD = Math.pow(2, 53);
/**
 * @param message
 * @param lineNumber
 */
function syntaxError(message, lineNumber) {
    assert(isString(message), "message must be a string");
    assert(isNumber(lineNumber), "lineNumber must be a number");
    var e = new SyntaxError(message /*, fileName*/);
    e['lineNumber'] = lineNumber;
    return e;
}
var Compiling = (function () {
    function Compiling(encoding) {
        this.c_encoding = encoding;
    }
    return Compiling;
}());
function REQ(n, type) {
    assert(n.type === type, "node wasn't expected type");
}
function strobj(s) {
    assert(typeof s === "string", "expecting string, got " + (typeof s));
    // This previously constructed the runtime representation.
    // That may have had an string intern side effect?
    return s;
}
function numStmts(n) {
    switch (n.type) {
        case SYM.single_input:
            if (CHILD(n, 0).type === Tokens.T_NEWLINE)
                return 0;
            else
                return numStmts(CHILD(n, 0));
        case SYM.file_input:
            var cnt = 0;
            for (var i = 0; i < NCH(n); ++i) {
                var ch = CHILD(n, i);
                if (ch.type === SYM.stmt) {
                    cnt += numStmts(ch);
                }
            }
            return cnt;
        case SYM.stmt:
            return numStmts(CHILD(n, 0));
        case SYM.compound_stmt:
            return 1;
        case SYM.simple_stmt:
            return Math.floor(NCH(n) / 2); // div 2 is to remove count of ;s
        case SYM.suite:
            if (NCH(n) === 1)
                return numStmts(CHILD(n, 0));
            else {
                var cnt_1 = 0;
                for (var i = 2; i < NCH(n) - 1; ++i) {
                    cnt_1 += numStmts(CHILD(n, i));
                }
                return cnt_1;
            }
        default: {
            throw new Error("Non-statement found");
        }
    }
}
function forbiddenCheck(c, n, x, lineno) {
    if (x === "None")
        throw syntaxError("assignment to None", lineno);
    if (x === "True" || x === "False")
        throw syntaxError("assignment to True or False is forbidden", lineno);
}
/**
 * Set the context ctx for e, recursively traversing e.
 *
 * Only sets context for expr kinds that can appear in assignment context as
 * per the asdl file.
 */
function setContext(c, e, ctx, n) {
    assert(ctx !== AugStore && ctx !== AugLoad);
    var s = null;
    var exprName = null;
    if (e instanceof Attribute) {
        if (ctx === Store)
            forbiddenCheck(c, n, e.attr, n.lineno);
        e.ctx = ctx;
    }
    else if (e instanceof Name) {
        if (ctx === Store)
            forbiddenCheck(c, n, /*e.attr*/ void 0, n.lineno);
        e.ctx = ctx;
    }
    else if (e instanceof Subscript) {
        e.ctx = ctx;
    }
    else if (e instanceof List) {
        e.ctx = ctx;
        s = e.elts;
    }
    else if (e instanceof Tuple) {
        if (e.elts.length === 0) {
            throw syntaxError("can't assign to ()", n.lineno);
        }
        e.ctx = ctx;
        s = e.elts;
    }
    else if (e instanceof Lambda) {
        exprName = "lambda";
    }
    else if (e instanceof Call) {
        exprName = "function call";
    }
    else if (e instanceof BoolOp) {
        exprName = "operator";
    }
    else {
        switch (e.constructor) {
            case BoolOp:
            case BinOp:
            case UnaryOp:
                exprName = "operator";
                break;
            case GeneratorExp:
                exprName = "generator expression";
                break;
            case Yield:
                exprName = "yield expression";
                break;
            case ListComp:
                exprName = "list comprehension";
                break;
            case Dict:
            case Num:
            case Str:
                exprName = "literal";
                break;
            case Compare:
                exprName = "comparison expression";
                break;
            case IfExp:
                exprName = "conditional expression";
                break;
            default: {
                throw new Error("unhandled expression in assignment");
            }
        }
    }
    if (exprName) {
        throw syntaxError("can't " + (ctx === Store ? "assign to" : "delete") + " " + exprName, n.lineno);
    }
    if (s) {
        for (var i = 0; i < s.length; ++i) {
            setContext(c, s[i], ctx, n);
        }
    }
}
var operatorMap = {};
(function () {
    operatorMap[Tokens.T_VBAR] = BitOr;
    operatorMap[Tokens.T_VBAR] = BitOr;
    operatorMap[Tokens.T_CIRCUMFLEX] = BitXor;
    operatorMap[Tokens.T_AMPER] = BitAnd;
    operatorMap[Tokens.T_LEFTSHIFT] = LShift;
    operatorMap[Tokens.T_RIGHTSHIFT] = RShift;
    operatorMap[Tokens.T_PLUS] = Add;
    operatorMap[Tokens.T_MINUS] = Sub;
    operatorMap[Tokens.T_STAR] = Mult;
    operatorMap[Tokens.T_SLASH] = Div;
    operatorMap[Tokens.T_DOUBLESLASH] = FloorDiv;
    operatorMap[Tokens.T_PERCENT] = Mod;
}());
function getOperator(n) {
    assert(operatorMap[n.type] !== undefined);
    return operatorMap[n.type];
}
function astForCompOp(c, n) {
    // comp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is' |'is' 'not'
    REQ(n, SYM.comp_op);
    if (NCH(n) === 1) {
        n = CHILD(n, 0);
        switch (n.type) {
            case Tokens.T_LESS: return Lt;
            case Tokens.T_GREATER: return Gt;
            case Tokens.T_EQEQUAL: return Eq;
            case Tokens.T_LESSEQUAL: return LtE;
            case Tokens.T_GREATEREQUAL: return GtE;
            case Tokens.T_NOTEQUAL: return NotEq;
            case Tokens.T_NAME:
                if (n.value === "in")
                    return In;
                if (n.value === "is")
                    return Is;
        }
    }
    else if (NCH(n) === 2) {
        if (CHILD(n, 0).type === Tokens.T_NAME) {
            if (CHILD(n, 1).value === "in")
                return NotIn;
            if (CHILD(n, 0).value === "is")
                return IsNot;
        }
    }
    throw new Error("invalid comp_op");
}
function seqForTestlist(c, n) {
    /* testlist: test (',' test)* [','] */
    assert(n.type === SYM.testlist ||
        n.type === SYM.listmaker ||
        n.type === SYM.testlist_gexp ||
        n.type === SYM.testlist_safe ||
        n.type === SYM.testlist1);
    var seq = [];
    for (var i = 0; i < NCH(n); i += 2) {
        assert(CHILD(n, i).type === SYM.IfExpr || CHILD(n, i).type === SYM.old_test);
        seq[i / 2] = astForExpr(c, CHILD(n, i));
    }
    return seq;
}
function astForSuite(c, n) {
    /* suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT */
    REQ(n, SYM.suite);
    var seq = [];
    var pos = 0;
    var ch;
    if (CHILD(n, 0).type === SYM.simple_stmt) {
        n = CHILD(n, 0);
        /* simple_stmt always ends with an NEWLINE and may have a trailing
            * SEMI. */
        var end = NCH(n) - 1;
        if (CHILD(n, end - 1).type === Tokens.T_SEMI) {
            end -= 1;
        }
        // by 2 to skip
        for (var i = 0; i < end; i += 2) {
            seq[pos++] = astForStmt(c, CHILD(n, i));
        }
    }
    else {
        for (var i = 2; i < NCH(n) - 1; ++i) {
            ch = CHILD(n, i);
            REQ(ch, SYM.stmt);
            var num = numStmts(ch);
            if (num === 1) {
                // small_stmt or compound_stmt w/ only 1 child
                seq[pos++] = astForStmt(c, ch);
            }
            else {
                ch = CHILD(ch, 0);
                REQ(ch, SYM.simple_stmt);
                for (var j = 0; j < NCH(ch); j += 2) {
                    if (NCH(CHILD(ch, j)) === 0) {
                        assert(j + 1 === NCH(ch));
                        break;
                    }
                    seq[pos++] = astForStmt(c, CHILD(ch, j));
                }
            }
        }
    }
    assert(pos === numStmts(n));
    return seq;
}
function astForExceptClause(c, exc, body) {
    /* except_clause: 'except' [test [(',' | 'as') test]] */
    REQ(exc, SYM.except_clause);
    REQ(body, SYM.suite);
    if (NCH(exc) === 1)
        return new ExceptHandler(null, null, astForSuite(c, body), exc.lineno, exc.col_offset);
    else if (NCH(exc) === 2)
        return new ExceptHandler(astForExpr(c, CHILD(exc, 1)), null, astForSuite(c, body), exc.lineno, exc.col_offset);
    else if (NCH(exc) === 4) {
        var e = astForExpr(c, CHILD(exc, 3));
        setContext(c, e, Store, CHILD(exc, 3));
        return new ExceptHandler(astForExpr(c, CHILD(exc, 1)), e, astForSuite(c, body), exc.lineno, exc.col_offset);
    }
    else {
        throw new Error("wrong number of children for except clause");
    }
}
function astForTryStmt(c, n) {
    var nc = NCH(n);
    var nexcept = (nc - 3) / 3;
    var orelse = [];
    var finally_ = null;
    REQ(n, SYM.try_stmt);
    var body = astForSuite(c, CHILD(n, 2));
    if (CHILD(n, nc - 3).type === Tokens.T_NAME) {
        if (CHILD(n, nc - 3).value === "finally") {
            if (nc >= 9 && CHILD(n, nc - 6).type === Tokens.T_NAME) {
                /* we can assume it's an "else",
                    because nc >= 9 for try-else-finally and
                    it would otherwise have a type of except_clause */
                orelse = astForSuite(c, CHILD(n, nc - 4));
                nexcept--;
            }
            finally_ = astForSuite(c, CHILD(n, nc - 1));
            nexcept--;
        }
        else {
            /* we can assume it's an "else",
                otherwise it would have a type of except_clause */
            orelse = astForSuite(c, CHILD(n, nc - 1));
            nexcept--;
        }
    }
    else if (CHILD(n, nc - 3).type !== SYM.except_clause) {
        throw syntaxError("malformed 'try' statement", n.lineno);
    }
    if (nexcept > 0) {
        var handlers = [];
        for (var i = 0; i < nexcept; ++i)
            handlers[i] = astForExceptClause(c, CHILD(n, 3 + i * 3), CHILD(n, 5 + i * 3));
        var exceptSt = new TryExcept(body, handlers, orelse, n.lineno, n.col_offset);
        if (!finally_)
            return exceptSt;
        /* if a 'finally' is present too, we nest the TryExcept within a
            TryFinally to emulate try ... except ... finally */
        body = [exceptSt];
    }
    assert(finally_ !== null);
    return new TryFinally(body, finally_, n.lineno, n.col_offset);
}
function astForDottedName(c, n) {
    REQ(n, SYM.dotted_name);
    var lineno = n.lineno;
    var col_offset = n.col_offset;
    var id = strobj(CHILD(n, 0).value);
    var e = new Name(id, Load, lineno, col_offset);
    for (var i = 2; i < NCH(n); i += 2) {
        id = strobj(CHILD(n, i).value);
        e = new Attribute(e, id, Load, lineno, col_offset);
    }
    return e;
}
function astForDecorator(c, n) {
    /* decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE */
    REQ(n, SYM.decorator);
    REQ(CHILD(n, 0), Tokens.T_AT);
    REQ(CHILD(n, NCH(n) - 1), Tokens.T_NEWLINE);
    var nameExpr = astForDottedName(c, CHILD(n, 1));
    if (NCH(n) === 3)
        return nameExpr;
    else if (NCH(n) === 5)
        return new Call(nameExpr, [], [], null, null, n.lineno, n.col_offset);
    else
        return astForCall(c, CHILD(n, 3), nameExpr);
}
function astForDecorators(c, n) {
    REQ(n, SYM.decorators);
    var decoratorSeq = [];
    for (var i = 0; i < NCH(n); ++i) {
        decoratorSeq[i] = astForDecorator(c, CHILD(n, i));
    }
    return decoratorSeq;
}
function astForDecorated(c, n) {
    REQ(n, SYM.decorated);
    var decoratorSeq = astForDecorators(c, CHILD(n, 0));
    assert(CHILD(n, 1).type === SYM.funcdef || CHILD(n, 1).type === SYM.classdef);
    var thing = null;
    if (CHILD(n, 1).type === SYM.funcdef) {
        thing = astForFuncdef(c, CHILD(n, 1), decoratorSeq);
    }
    else if (CHILD(n, 1).type === SYM.classdef) {
        thing = astForClassdef(c, CHILD(n, 1), decoratorSeq);
    }
    else {
        throw new Error("astForDecorated");
    }
    if (thing) {
        thing.lineno = n.lineno;
        thing.col_offset = n.col_offset;
    }
    return thing;
}
function astForWithVar(c, n) {
    REQ(n, SYM.with_var);
    return astForExpr(c, CHILD(n, 1));
}
function astForWithStmt(c, n) {
    /* with_stmt: 'with' test [ with_var ] ':' suite */
    var suiteIndex = 3; // skip with, test, :
    assert(n.type === SYM.with_stmt);
    var contextExpr = astForExpr(c, CHILD(n, 1));
    var optionalVars;
    if (CHILD(n, 2).type === SYM.with_var) {
        optionalVars = astForWithVar(c, CHILD(n, 2));
        setContext(c, optionalVars, Store, n);
        suiteIndex = 4;
    }
    return new WithStatement(contextExpr, optionalVars, astForSuite(c, CHILD(n, suiteIndex)), n.lineno, n.col_offset);
}
function astForExecStmt(c, n) {
    var globals = null;
    var locals = null;
    var nchildren = NCH(n);
    assert(nchildren === 2 || nchildren === 4 || nchildren === 6);
    /* exec_stmt: 'exec' expr ['in' test [',' test]] */
    REQ(n, SYM.exec_stmt);
    var expr1 = astForExpr(c, CHILD(n, 1));
    if (nchildren >= 4) {
        globals = astForExpr(c, CHILD(n, 3));
    }
    if (nchildren === 6) {
        locals = astForExpr(c, CHILD(n, 5));
    }
    return new Exec(expr1, globals, locals, n.lineno, n.col_offset);
}
function astForIfStmt(c, n) {
    /* if_stmt: 'if' test ':' suite ('elif' test ':' suite)*
        ['else' ':' suite]
    */
    REQ(n, SYM.if_stmt);
    if (NCH(n) === 4)
        return new IfStatement(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), [], n.lineno, n.col_offset);
    var s = CHILD(n, 4).value;
    var decider = s.charAt(2); // elSe or elIf
    if (decider === 's') {
        return new IfStatement(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 6)), n.lineno, n.col_offset);
    }
    else if (decider === 'i') {
        var nElif = NCH(n) - 4;
        var hasElse = false;
        var orelse = [];
        /* must reference the child nElif+1 since 'else' token is third, not
            * fourth child from the end. */
        if (CHILD(n, nElif + 1).type === Tokens.T_NAME && CHILD(n, nElif + 1).value.charAt(2) === 's') {
            hasElse = true;
            nElif -= 3;
        }
        nElif /= 4;
        if (hasElse) {
            orelse = [
                new IfStatement(astForExpr(c, CHILD(n, NCH(n) - 6)), astForSuite(c, CHILD(n, NCH(n) - 4)), astForSuite(c, CHILD(n, NCH(n) - 1)), CHILD(n, NCH(n) - 6).lineno, CHILD(n, NCH(n) - 6).col_offset)
            ];
            nElif--;
        }
        for (var i = 0; i < nElif; ++i) {
            var off = 5 + (nElif - i - 1) * 4;
            orelse = [
                new IfStatement(astForExpr(c, CHILD(n, off)), astForSuite(c, CHILD(n, off + 2)), orelse, CHILD(n, off).lineno, CHILD(n, off).col_offset)
            ];
        }
        return new IfStatement(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), orelse, n.lineno, n.col_offset);
    }
    throw new Error("unexpected token in 'if' statement");
}
function astForExprlist(c, n, context) {
    REQ(n, SYM.ExprList);
    var seq = [];
    for (var i = 0; i < NCH(n); i += 2) {
        var e = astForExpr(c, CHILD(n, i));
        seq[i / 2] = e;
        if (context)
            setContext(c, e, context, CHILD(n, i));
    }
    return seq;
}
function astForDelStmt(c, n) {
    REQ(n, SYM.del_stmt);
    return new DeleteExpression(astForExprlist(c, CHILD(n, 1), Del), n.lineno, n.col_offset);
}
function astForGlobalStmt(c, n) {
    REQ(n, SYM.GlobalStmt);
    var s = [];
    for (var i = 1; i < NCH(n); i += 2) {
        s[(i - 1) / 2] = strobj(CHILD(n, i).value);
    }
    return new Global(s, n.lineno, n.col_offset);
}
function astForNonLocalStmt(c, n) {
    REQ(n, SYM.NonLocalStmt);
    var s = [];
    for (var i = 1; i < NCH(n); i += 2) {
        s[(i - 1) / 2] = strobj(CHILD(n, i).value);
    }
    return new NonLocal(s, n.lineno, n.col_offset);
}
function astForAssertStmt(c, n) {
    /* assert_stmt: 'assert' test [',' test] */
    REQ(n, SYM.assert_stmt);
    if (NCH(n) === 2) {
        return new Assert(astForExpr(c, CHILD(n, 1)), null, n.lineno, n.col_offset);
    }
    else if (NCH(n) === 4) {
        return new Assert(astForExpr(c, CHILD(n, 1)), astForExpr(c, CHILD(n, 3)), n.lineno, n.col_offset);
    }
    throw new Error("improper number of parts to assert stmt");
}
function aliasForImportName(c, n) {
    /*
        import_as_name: NAME ['as' NAME]
        dotted_as_name: dotted_name ['as' NAME]
        dotted_name: NAME ('.' NAME)*
    */
    loop: while (true) {
        switch (n.type) {
            case SYM.import_as_name:
                var str = null;
                var name_1 = strobj(CHILD(n, 0).value);
                if (NCH(n) === 3)
                    str = CHILD(n, 2).value;
                return new Alias(name_1, str == null ? null : strobj(str));
            case SYM.dotted_as_name:
                if (NCH(n) === 1) {
                    n = CHILD(n, 0);
                    continue loop;
                }
                else {
                    var a = aliasForImportName(c, CHILD(n, 0));
                    assert(!a.asname);
                    a.asname = strobj(CHILD(n, 2).value);
                    return a;
                }
            case SYM.dotted_name:
                if (NCH(n) === 1)
                    return new Alias(strobj(CHILD(n, 0).value), null);
                else {
                    // create a string of the form a.b.c
                    var str_1 = '';
                    for (var i = 0; i < NCH(n); i += 2)
                        str_1 += CHILD(n, i).value + ".";
                    return new Alias(strobj(str_1.substr(0, str_1.length - 1)), null);
                }
            case Tokens.T_STAR:
                return new Alias(strobj("*"), null);
            default:
                throw syntaxError("unexpected import name", n.lineno);
        }
    }
}
function astForImportStmt(c, n) {
    REQ(n, SYM.import_stmt);
    var lineno = n.lineno;
    var col_offset = n.col_offset;
    n = CHILD(n, 0);
    if (n.type === SYM.import_name) {
        n = CHILD(n, 1);
        REQ(n, SYM.dotted_as_names);
        var aliases = [];
        for (var i = 0; i < NCH(n); i += 2)
            aliases[i / 2] = aliasForImportName(c, CHILD(n, i));
        return new ImportStatement(aliases, lineno, col_offset);
    }
    else if (n.type === SYM.import_from) {
        var mod = null;
        var ndots = 0;
        var nchildren = void 0;
        var idx = void 0;
        for (idx = 1; idx < NCH(n); ++idx) {
            if (CHILD(n, idx).type === SYM.dotted_name) {
                mod = aliasForImportName(c, CHILD(n, idx));
                idx++;
                break;
            }
            else if (CHILD(n, idx).type !== Tokens.T_DOT)
                break;
            ndots++;
        }
        ++idx; // skip the import keyword
        switch (CHILD(n, idx).type) {
            case Tokens.T_STAR:
                // from ... import
                n = CHILD(n, idx);
                nchildren = 1;
                break;
            case Tokens.T_LPAR:
                // from ... import (x, y, z)
                n = CHILD(n, idx + 1);
                nchildren = NCH(n);
                break;
            case SYM.import_as_names:
                // from ... import x, y, z
                n = CHILD(n, idx);
                nchildren = NCH(n);
                if (nchildren % 2 === 0)
                    throw syntaxError("trailing comma not allowed without surrounding parentheses", n.lineno);
        }
        var aliases = [];
        if (n.type === Tokens.T_STAR)
            aliases[0] = aliasForImportName(c, n);
        else
            for (var i = 0; i < NCH(n); i += 2) {
                aliases[i / 2] = aliasForImportName(c, CHILD(n, i));
            }
        var modname = mod ? mod.name : "";
        return new ImportFrom(strobj(modname), aliases, ndots, lineno, col_offset);
    }
    throw syntaxError("unknown import statement", n.lineno);
}
function astForTestlistGexp(c, n) {
    assert(n.type === SYM.testlist_gexp || n.type === SYM.argument);
    if (NCH(n) > 1 && CHILD(n, 1).type === SYM.gen_for)
        return astForGenexp(c, n);
    return astForTestlist(c, n);
}
function astForListcomp(c, n) {
    function countListFors(c, n) {
        var nfors = 0;
        var ch = CHILD(n, 1);
        count_list_for: while (true) {
            nfors++;
            REQ(ch, SYM.list_for);
            if (NCH(ch) === 5)
                ch = CHILD(ch, 4);
            else
                return nfors;
            count_list_iter: while (true) {
                REQ(ch, SYM.list_iter);
                ch = CHILD(ch, 0);
                if (ch.type === SYM.list_for)
                    continue count_list_for;
                else if (ch.type === SYM.list_if) {
                    if (NCH(ch) === 3) {
                        ch = CHILD(ch, 2);
                        continue count_list_iter;
                    }
                    else
                        return nfors;
                }
                break;
            }
            // FIXME: What does a break at the end of a function do?
            break;
        }
        throw new Error("TODO: Should this be returning void 0?");
    }
    function countListIfs(c, n) {
        var nifs = 0;
        while (true) {
            REQ(n, SYM.list_iter);
            if (CHILD(n, 0).type === SYM.list_for)
                return nifs;
            n = CHILD(n, 0);
            REQ(n, SYM.list_if);
            nifs++;
            if (NCH(n) === 2)
                return nifs;
            n = CHILD(n, 2);
        }
    }
    REQ(n, SYM.listmaker);
    assert(NCH(n) > 1);
    var elt = astForExpr(c, CHILD(n, 0));
    var nfors = countListFors(c, n);
    var listcomps = [];
    var ch = CHILD(n, 1);
    for (var i = 0; i < nfors; ++i) {
        REQ(ch, SYM.list_for);
        var forch = CHILD(ch, 1);
        var t = astForExprlist(c, forch, Store);
        var expression = astForTestlist(c, CHILD(ch, 3));
        var lc = void 0;
        if (NCH(forch) === 1)
            lc = new Comprehension(t[0], expression, []);
        else
            lc = new Comprehension(new Tuple(t, Store, ch.lineno, ch.col_offset), expression, []);
        if (NCH(ch) === 5) {
            ch = CHILD(ch, 4);
            var nifs = countListIfs(c, ch);
            var ifs = [];
            for (var j = 0; j < nifs; ++j) {
                REQ(ch, SYM.list_iter);
                ch = CHILD(ch, 0);
                REQ(ch, SYM.list_if);
                ifs[j] = astForExpr(c, CHILD(ch, 1));
                if (NCH(ch) === 3)
                    ch = CHILD(ch, 2);
            }
            if (ch.type === SYM.list_iter)
                ch = CHILD(ch, 0);
            lc.ifs = ifs;
        }
        listcomps[i] = lc;
    }
    return new ListComp(elt, listcomps, n.lineno, n.col_offset);
}
function astForUnaryExpr(c, n) {
    if (CHILD(n, 0).type === Tokens.T_MINUS && NCH(n) === 2) {
        var pfactor = CHILD(n, 1);
        if (pfactor.type === SYM.UnaryExpr && NCH(pfactor) === 1) {
            var ppower = CHILD(pfactor, 0);
            if (ppower.type === SYM.PowerExpr && NCH(ppower) === 1) {
                var patom = CHILD(ppower, 0);
                if (patom.type === SYM.AtomExpr) {
                    var pnum = CHILD(patom, 0);
                    if (pnum.type === Tokens.T_NUMBER) {
                        pnum.value = "-" + pnum.value;
                        return astForAtomExpr(c, patom);
                    }
                }
            }
        }
    }
    var expression = astForExpr(c, CHILD(n, 1));
    switch (CHILD(n, 0).type) {
        case Tokens.T_PLUS: return new UnaryOp(UAdd, expression, n.lineno, n.col_offset);
        case Tokens.T_MINUS: return new UnaryOp(USub, expression, n.lineno, n.col_offset);
        case Tokens.T_TILDE: return new UnaryOp(Invert, expression, n.lineno, n.col_offset);
    }
    throw new Error("unhandled UnaryExpr");
}
function astForForStmt(c, n) {
    var seq = [];
    REQ(n, SYM.for_stmt);
    if (NCH(n) === 9) {
        seq = astForSuite(c, CHILD(n, 8));
    }
    var nodeTarget = CHILD(n, 1);
    var _target = astForExprlist(c, nodeTarget, Store);
    var target;
    if (NCH(nodeTarget) === 1)
        target = _target[0];
    else
        target = new Tuple(_target, Store, n.lineno, n.col_offset);
    return new ForStatement(target, astForTestlist(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 5)), seq, n.lineno, n.col_offset);
}
function astForCall(c, n, func) {
    /*
        arglist: (argument ',')* (argument [',']| '*' test [',' '**' test]
                | '**' test)
        argument: [test '='] test [gen_for]        # Really [keyword '='] test
    */
    REQ(n, SYM.arglist);
    var nargs = 0;
    var nkeywords = 0;
    var ngens = 0;
    for (var i = 0; i < NCH(n); ++i) {
        var ch = CHILD(n, i);
        if (ch.type === SYM.argument) {
            if (NCH(ch) === 1)
                nargs++;
            else if (CHILD(ch, 1).type === SYM.gen_for)
                ngens++;
            else
                nkeywords++;
        }
    }
    if (ngens > 1 || (ngens && (nargs || nkeywords)))
        throw syntaxError("Generator expression must be parenthesized if not sole argument", n.lineno);
    if (nargs + nkeywords + ngens > 255)
        throw syntaxError("more than 255 arguments", n.lineno);
    var args = [];
    var keywords = [];
    nargs = 0;
    nkeywords = 0;
    var vararg = null;
    var kwarg = null;
    for (var i = 0; i < NCH(n); ++i) {
        var ch = CHILD(n, i);
        if (ch.type === SYM.argument) {
            if (NCH(ch) === 1) {
                if (nkeywords)
                    throw syntaxError("non-keyword arg after keyword arg", n.lineno);
                if (vararg)
                    throw syntaxError("only named arguments may follow *expression", n.lineno);
                args[nargs++] = astForExpr(c, CHILD(ch, 0));
            }
            else if (CHILD(ch, 1).type === SYM.gen_for)
                args[nargs++] = astForGenexp(c, ch);
            else {
                var e = astForExpr(c, CHILD(ch, 0));
                if (e.constructor === Lambda)
                    throw syntaxError("lambda cannot contain assignment", n.lineno);
                else if (e.constructor !== Name)
                    throw syntaxError("keyword can't be an expression", n.lineno);
                var key = e.id;
                forbiddenCheck(c, CHILD(ch, 0), key, n.lineno);
                for (var k = 0; k < nkeywords; ++k) {
                    var tmp = keywords[k].arg;
                    if (tmp === key)
                        throw syntaxError("keyword argument repeated", n.lineno);
                }
                keywords[nkeywords++] = new Keyword(key, astForExpr(c, CHILD(ch, 2)));
            }
        }
        else if (ch.type === Tokens.T_STAR)
            vararg = astForExpr(c, CHILD(n, ++i));
        else if (ch.type === Tokens.T_DOUBLESTAR)
            kwarg = astForExpr(c, CHILD(n, ++i));
    }
    return new Call(func, args, keywords, vararg, kwarg, func.lineno, func.col_offset);
}
function astForTrailer(c, n, leftExpr) {
    /* trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME
        subscriptlist: subscript (',' subscript)* [',']
        subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]
        */
    REQ(n, SYM.trailer);
    if (CHILD(n, 0).type === Tokens.T_LPAR) {
        if (NCH(n) === 2)
            return new Call(leftExpr, [], [], null, null, n.lineno, n.col_offset);
        else
            return astForCall(c, CHILD(n, 1), leftExpr);
    }
    else if (CHILD(n, 0).type === Tokens.T_DOT)
        return new Attribute(leftExpr, strobj(CHILD(n, 1).value), Load, n.lineno, n.col_offset);
    else {
        REQ(CHILD(n, 0), Tokens.T_LSQB);
        REQ(CHILD(n, 2), Tokens.T_RSQB);
        n = CHILD(n, 1);
        if (NCH(n) === 1)
            return new Subscript(leftExpr, astForSlice(c, CHILD(n, 0)), Load, n.lineno, n.col_offset);
        else {
            /* The grammar is ambiguous here. The ambiguity is resolved
                by treating the sequence as a tuple literal if there are
                no slice features.
            */
            var simple = true;
            var slices = [];
            for (var j = 0; j < NCH(n); j += 2) {
                var slc = astForSlice(c, CHILD(n, j));
                if (slc.constructor !== Index) {
                    simple = false;
                }
                slices[j / 2] = slc;
            }
            if (!simple) {
                return new Subscript(leftExpr, new ExtSlice(slices), Load, n.lineno, n.col_offset);
            }
            var elts = [];
            for (var j = 0; j < slices.length; ++j) {
                var slc = slices[j];
                if (slc instanceof Index) {
                    assert(slc.value !== null && slc.value !== undefined);
                    elts[j] = slc.value;
                }
                else {
                    assert(slc instanceof Index);
                }
            }
            var e = new Tuple(elts, Load, n.lineno, n.col_offset);
            return new Subscript(leftExpr, new Index(e), Load, n.lineno, n.col_offset);
        }
    }
}
function astForFlowStmt(c, n) {
    REQ(n, SYM.flow_stmt);
    var ch = CHILD(n, 0);
    switch (ch.type) {
        case SYM.break_stmt: return new BreakStatement(n.lineno, n.col_offset);
        case SYM.continue_stmt: return new ContinueStatement(n.lineno, n.col_offset);
        case SYM.yield_stmt:
            return new Expr(astForExpr(c, CHILD(ch, 0)), n.lineno, n.col_offset);
        case SYM.return_stmt:
            if (NCH(ch) === 1)
                return new ReturnStatement(null, n.lineno, n.col_offset);
            else
                return new ReturnStatement(astForTestlist(c, CHILD(ch, 1)), n.lineno, n.col_offset);
        case SYM.raise_stmt: {
            if (NCH(ch) === 1)
                return new Raise(null, null, null, n.lineno, n.col_offset);
            else if (NCH(ch) === 2)
                return new Raise(astForExpr(c, CHILD(ch, 1)), null, null, n.lineno, n.col_offset);
            else if (NCH(ch) === 4)
                return new Raise(astForExpr(c, CHILD(ch, 1)), astForExpr(c, CHILD(ch, 3)), null, n.lineno, n.col_offset);
            else if (NCH(ch) === 6)
                return new Raise(astForExpr(c, CHILD(ch, 1)), astForExpr(c, CHILD(ch, 3)), astForExpr(c, CHILD(ch, 5)), n.lineno, n.col_offset);
            else {
                throw new Error("unhandled flow statement");
            }
        }
        default: {
            throw new Error("unexpected flow_stmt");
        }
    }
}
function astForArguments(c, n) {
    /* parameters: '(' [varargslist] ')'
        varargslist: (fpdef ['=' test] ',')* ('*' NAME [',' '**' NAME]
            | '**' NAME) | fpdef ['=' test] (',' fpdef ['=' test])* [',']
    */
    var ch;
    var vararg = null;
    var kwarg = null;
    if (n.type === SYM.parameters) {
        if (NCH(n) === 2)
            return new Arguments([], null, null, []);
        n = CHILD(n, 1);
    }
    REQ(n, SYM.varargslist);
    var args = [];
    var defaults = [];
    /* fpdef: NAME | '(' fplist ')'
        fplist: fpdef (',' fpdef)* [',']
    */
    var foundDefault = false;
    var i = 0;
    var j = 0; // index for defaults
    var k = 0; // index for args
    while (i < NCH(n)) {
        ch = CHILD(n, i);
        switch (ch.type) {
            case SYM.fpdef:
                var complexArgs = 0;
                var parenthesized = false;
                handle_fpdef: while (true) {
                    if (i + 1 < NCH(n) && CHILD(n, i + 1).type === Tokens.T_EQUAL) {
                        defaults[j++] = astForExpr(c, CHILD(n, i + 2));
                        i += 2;
                        foundDefault = true;
                    }
                    else if (foundDefault) {
                        /* def f((x)=4): pass should raise an error.
                            def f((x, (y))): pass will just incur the tuple unpacking warning. */
                        if (parenthesized && !complexArgs)
                            throw syntaxError("parenthesized arg with default", n.lineno);
                        throw syntaxError("non-default argument follows default argument", n.lineno);
                    }
                    if (NCH(ch) === 3) {
                        ch = CHILD(ch, 1);
                        // def foo((x)): is not complex, special case.
                        if (NCH(ch) !== 1) {
                            throw syntaxError("tuple parameter unpacking has been removed", n.lineno);
                        }
                        else {
                            /* def foo((x)): setup for checking NAME below. */
                            /* Loop because there can be many parens and tuple
                                unpacking mixed in. */
                            parenthesized = true;
                            ch = CHILD(ch, 0);
                            assert(ch.type === SYM.fpdef);
                            continue handle_fpdef;
                        }
                    }
                    if (CHILD(ch, 0).type === Tokens.T_NAME) {
                        forbiddenCheck(c, n, CHILD(ch, 0).value, n.lineno);
                        var id = strobj(CHILD(ch, 0).value);
                        args[k++] = new Name(id, Param, ch.lineno, ch.col_offset);
                    }
                    i += 2;
                    if (parenthesized)
                        throw syntaxError("parenthesized argument names are invalid", n.lineno);
                    break;
                }
                break;
            case Tokens.T_STAR:
                forbiddenCheck(c, CHILD(n, i + 1), CHILD(n, i + 1).value, n.lineno);
                vararg = strobj(CHILD(n, i + 1).value);
                i += 3;
                break;
            case Tokens.T_DOUBLESTAR:
                forbiddenCheck(c, CHILD(n, i + 1), CHILD(n, i + 1).value, n.lineno);
                kwarg = strobj(CHILD(n, i + 1).value);
                i += 3;
                break;
            default: {
                throw new Error("unexpected node in varargslist");
            }
        }
    }
    return new Arguments(args, vararg, kwarg, defaults);
}
function astForFuncdef(c, n, decoratorSeq) {
    /* funcdef: 'def' NAME parameters ':' suite */
    REQ(n, SYM.funcdef);
    var name = strobj(CHILD(n, 1).value);
    forbiddenCheck(c, CHILD(n, 1), CHILD(n, 1).value, n.lineno);
    var args = astForArguments(c, CHILD(n, 2));
    var body = astForSuite(c, CHILD(n, 4));
    return new FunctionDef(name, args, body, decoratorSeq, n.lineno, n.col_offset);
}
function astForClassBases(c, n) {
    assert(NCH(n) > 0);
    REQ(n, SYM.testlist);
    if (NCH(n) === 1) {
        return [astForExpr(c, CHILD(n, 0))];
    }
    return seqForTestlist(c, n);
}
function astForClassdef(c, n, decoratorSeq) {
    REQ(n, SYM.classdef);
    forbiddenCheck(c, n, CHILD(n, 1).value, n.lineno);
    var classname = strobj(CHILD(n, 1).value);
    if (NCH(n) === 4)
        return new ClassDef(classname, [], astForSuite(c, CHILD(n, 3)), decoratorSeq, n.lineno, n.col_offset);
    if (CHILD(n, 3).type === Tokens.T_RPAR)
        return new ClassDef(classname, [], astForSuite(c, CHILD(n, 5)), decoratorSeq, n.lineno, n.col_offset);
    var bases = astForClassBases(c, CHILD(n, 3));
    var s = astForSuite(c, CHILD(n, 6));
    return new ClassDef(classname, bases, s, decoratorSeq, n.lineno, n.col_offset);
}
function astForLambdef(c, n) {
    var args;
    var expression;
    if (NCH(n) === 3) {
        args = new Arguments([], null, null, []);
        expression = astForExpr(c, CHILD(n, 2));
    }
    else {
        args = astForArguments(c, CHILD(n, 1));
        expression = astForExpr(c, CHILD(n, 3));
    }
    return new Lambda(args, expression, n.lineno, n.col_offset);
}
function astForGenexp(c, n) {
    /* testlist_gexp: test ( gen_for | (',' test)* [','] )
        argument: [test '='] test [gen_for]       # Really [keyword '='] test */
    assert(n.type === SYM.testlist_gexp || n.type === SYM.argument);
    assert(NCH(n) > 1);
    function countGenFors(c, n) {
        var nfors = 0;
        var ch = CHILD(n, 1);
        count_gen_for: while (true) {
            nfors++;
            REQ(ch, SYM.gen_for);
            if (NCH(ch) === 5)
                ch = CHILD(ch, 4);
            else
                return nfors;
            count_gen_iter: while (true) {
                REQ(ch, SYM.gen_iter);
                ch = CHILD(ch, 0);
                if (ch.type === SYM.gen_for)
                    continue count_gen_for;
                else if (ch.type === SYM.gen_if) {
                    if (NCH(ch) === 3) {
                        ch = CHILD(ch, 2);
                        continue count_gen_iter;
                    }
                    else
                        return nfors;
                }
                break;
            }
            break;
        }
        throw new Error("logic error in countGenFors");
    }
    function countGenIfs(c, n) {
        var nifs = 0;
        while (true) {
            REQ(n, SYM.gen_iter);
            if (CHILD(n, 0).type === SYM.gen_for)
                return nifs;
            n = CHILD(n, 0);
            REQ(n, SYM.gen_if);
            nifs++;
            if (NCH(n) === 2)
                return nifs;
            n = CHILD(n, 2);
        }
    }
    var elt = astForExpr(c, CHILD(n, 0));
    var nfors = countGenFors(c, n);
    var genexps = [];
    var ch = CHILD(n, 1);
    for (var i = 0; i < nfors; ++i) {
        REQ(ch, SYM.gen_for);
        var forch = CHILD(ch, 1);
        var t = astForExprlist(c, forch, Store);
        var expression = astForExpr(c, CHILD(ch, 3));
        var ge = void 0;
        if (NCH(forch) === 1)
            ge = new Comprehension(t[0], expression, []);
        else
            ge = new Comprehension(new Tuple(t, Store, ch.lineno, ch.col_offset), expression, []);
        if (NCH(ch) === 5) {
            ch = CHILD(ch, 4);
            var nifs = countGenIfs(c, ch);
            var ifs = [];
            for (var j = 0; j < nifs; ++j) {
                REQ(ch, SYM.gen_iter);
                ch = CHILD(ch, 0);
                REQ(ch, SYM.gen_if);
                expression = astForExpr(c, CHILD(ch, 1));
                ifs[j] = expression;
                if (NCH(ch) === 3)
                    ch = CHILD(ch, 2);
            }
            if (ch.type === SYM.gen_iter)
                ch = CHILD(ch, 0);
            ge.ifs = ifs;
        }
        genexps[i] = ge;
    }
    return new GeneratorExp(elt, genexps, n.lineno, n.col_offset);
}
function astForWhileStmt(c, n) {
    /* while_stmt: 'while' test ':' suite ['else' ':' suite] */
    REQ(n, SYM.while_stmt);
    if (NCH(n) === 4)
        return new WhileStatement(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), [], n.lineno, n.col_offset);
    else if (NCH(n) === 7)
        return new WhileStatement(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 6)), n.lineno, n.col_offset);
    throw new Error("wrong number of tokens for 'while' stmt");
}
function astForAugassign(c, n) {
    REQ(n, SYM.augassign);
    n = CHILD(n, 0);
    switch (n.value.charAt(0)) {
        case '+': return Add;
        case '-': return Sub;
        case '/': {
            if (n.value.charAt(1) === '/') {
                return FloorDiv;
            }
            else {
                return Div;
            }
        }
        case '%': return Mod;
        case '<': return LShift;
        case '>': return RShift;
        case '&': return BitAnd;
        case '^': return BitXor;
        case '|': return BitOr;
        case '*': {
            if (n.value.charAt(1) === '*') {
                return Pow;
            }
            else {
                return Mult;
            }
        }
        default: {
            throw new Error("invalid augassign");
        }
    }
}
function astForBinop(c, n) {
    /* Must account for a sequence of expressions.
        How should A op B op C by represented?
        BinOp(BinOp(A, op, B), op, C).
    */
    var result = new BinOp(astForExpr(c, CHILD(n, 0)), getOperator(CHILD(n, 1)), astForExpr(c, CHILD(n, 2)), n.lineno, n.col_offset);
    var nops = (NCH(n) - 1) / 2;
    for (var i = 1; i < nops; ++i) {
        var nextOper = CHILD(n, i * 2 + 1);
        var newoperator = getOperator(nextOper);
        var tmp = astForExpr(c, CHILD(n, i * 2 + 2));
        result = new BinOp(result, newoperator, tmp, nextOper.lineno, nextOper.col_offset);
    }
    return result;
}
function astForTestlist(c, n) {
    /* testlist_gexp: test (',' test)* [','] */
    /* testlist: test (',' test)* [','] */
    /* testlist_safe: test (',' test)+ [','] */
    /* testlist1: test (',' test)* */
    assert(NCH(n) > 0);
    if (n.type === SYM.testlist_gexp) {
        if (NCH(n) > 1) {
            assert(CHILD(n, 1).type !== SYM.gen_for);
        }
    }
    else {
        assert(n.type === SYM.testlist || n.type === SYM.testlist_safe || n.type === SYM.testlist1);
    }
    if (NCH(n) === 1) {
        return astForExpr(c, CHILD(n, 0));
    }
    else {
        return new Tuple(seqForTestlist(c, n), Load, n.lineno, n.col_offset);
    }
}
function astForExprStmt(c, n) {
    REQ(n, SYM.ExprStmt);
    if (NCH(n) === 1)
        return new Expr(astForTestlist(c, CHILD(n, 0)), n.lineno, n.col_offset);
    else if (CHILD(n, 1).type === SYM.augassign) {
        var ch = CHILD(n, 0);
        var expr1 = astForTestlist(c, ch);
        switch (expr1.constructor) {
            case GeneratorExp: throw syntaxError("augmented assignment to generator expression not possible", n.lineno);
            case Yield: throw syntaxError("augmented assignment to yield expression not possible", n.lineno);
            case Name:
                var varName = expr1.id;
                forbiddenCheck(c, ch, varName, n.lineno);
                break;
            case Attribute:
            case Subscript:
                break;
            default:
                throw syntaxError("illegal expression for augmented assignment", n.lineno);
        }
        setContext(c, expr1, Store, ch);
        ch = CHILD(n, 2);
        var expr2 = void 0;
        if (ch.type === SYM.testlist)
            expr2 = astForTestlist(c, ch);
        else
            expr2 = astForExpr(c, ch);
        return new AugAssign(expr1, astForAugassign(c, CHILD(n, 1)), expr2, n.lineno, n.col_offset);
    }
    else {
        // normal assignment
        REQ(CHILD(n, 1), Tokens.T_EQUAL);
        var targets = [];
        for (var i = 0; i < NCH(n) - 2; i += 2) {
            var ch = CHILD(n, i);
            if (ch.type === SYM.YieldExpr)
                throw syntaxError("assignment to yield expression not possible", n.lineno);
            var e = astForTestlist(c, ch);
            setContext(c, e, Store, CHILD(n, i));
            targets[i / 2] = e;
        }
        var value = CHILD(n, NCH(n) - 1);
        var expression = void 0;
        if (value.type === SYM.testlist)
            expression = astForTestlist(c, value);
        else
            expression = astForExpr(c, value);
        return new Assign(targets, expression, n.lineno, n.col_offset);
    }
}
function astForIfexpr(c, n) {
    assert(NCH(n) === 5);
    return new IfExp(astForExpr(c, CHILD(n, 2)), astForExpr(c, CHILD(n, 0)), astForExpr(c, CHILD(n, 4)), n.lineno, n.col_offset);
}
// escape() was deprecated in JavaScript 1.5. Use encodeURI or encodeURIComponent instead.
function escape(s) {
    return encodeURIComponent(s);
}
/**
 * s is a python-style string literal, including quote characters and u/r/b
 * prefixes. Returns decoded string object.
 */
function parsestr(c, s) {
    // const encodeUtf8 = function(s) { return unescape(encodeURIComponent(s)); };
    var decodeUtf8 = function (s) { return decodeURIComponent(escape(s)); };
    var decodeEscape = function (s, quote) {
        var len = s.length;
        var ret = '';
        for (var i = 0; i < len; ++i) {
            var c_1 = s.charAt(i);
            if (c_1 === '\\') {
                ++i;
                c_1 = s.charAt(i);
                if (c_1 === 'n')
                    ret += "\n";
                else if (c_1 === '\\')
                    ret += "\\";
                else if (c_1 === 't')
                    ret += "\t";
                else if (c_1 === 'r')
                    ret += "\r";
                else if (c_1 === 'b')
                    ret += "\b";
                else if (c_1 === 'f')
                    ret += "\f";
                else if (c_1 === 'v')
                    ret += "\v";
                else if (c_1 === '0')
                    ret += "\0";
                else if (c_1 === '"')
                    ret += '"';
                else if (c_1 === '\'')
                    ret += '\'';
                else if (c_1 === '\n') { }
                else if (c_1 === 'x') {
                    var d0 = s.charAt(++i);
                    var d1 = s.charAt(++i);
                    ret += String.fromCharCode(parseInt(d0 + d1, 16));
                }
                else if (c_1 === 'u' || c_1 === 'U') {
                    var d0 = s.charAt(++i);
                    var d1 = s.charAt(++i);
                    var d2 = s.charAt(++i);
                    var d3 = s.charAt(++i);
                    ret += String.fromCharCode(parseInt(d0 + d1, 16), parseInt(d2 + d3, 16));
                }
                else {
                    // Leave it alone
                    ret += "\\" + c_1;
                }
            }
            else {
                ret += c_1;
            }
        }
        return ret;
    };
    var quote = s.charAt(0);
    var rawmode = false;
    if (quote === 'u' || quote === 'U') {
        s = s.substr(1);
        quote = s.charAt(0);
    }
    else if (quote === 'r' || quote === 'R') {
        s = s.substr(1);
        quote = s.charAt(0);
        rawmode = true;
    }
    assert(quote !== 'b' && quote !== 'B', "todo; haven't done b'' strings yet");
    assert(quote === "'" || quote === '"' && s.charAt(s.length - 1) === quote);
    s = s.substr(1, s.length - 2);
    if (s.length >= 4 && s.charAt(0) === quote && s.charAt(1) === quote) {
        assert(s.charAt(s.length - 1) === quote && s.charAt(s.length - 2) === quote);
        s = s.substr(2, s.length - 4);
    }
    if (rawmode || s.indexOf('\\') === -1) {
        return strobj(decodeUtf8(s));
    }
    return strobj(decodeEscape(s, quote));
}
/**
 * @return {string}
 */
function parsestrplus(c, n) {
    REQ(CHILD(n, 0), Tokens.T_STRING);
    var ret = "";
    for (var i = 0; i < NCH(n); ++i) {
        var child = CHILD(n, i);
        try {
            ret = ret + parsestr(c, child.value);
        }
        catch (x) {
            throw syntaxError("invalid string (possibly contains a unicode character)", child.lineno);
        }
    }
    return ret;
}
function parsenumber(c, s, lineno) {
    var end = s.charAt(s.length - 1);
    if (end === 'j' || end === 'J') {
        throw syntaxError("complex numbers are currently unsupported", lineno);
    }
    if (s.indexOf('.') !== -1) {
        return floatAST(s);
    }
    // Handle integers of various bases
    var tmp = s;
    var value;
    var radix = 10;
    var neg = false;
    if (s.charAt(0) === '-') {
        tmp = s.substr(1);
        neg = true;
    }
    if (tmp.charAt(0) === '0' && (tmp.charAt(1) === 'x' || tmp.charAt(1) === 'X')) {
        // Hex
        tmp = tmp.substring(2);
        value = parseInt(tmp, 16);
        radix = 16;
    }
    else if ((s.indexOf('e') !== -1) || (s.indexOf('E') !== -1)) {
        // Float with exponent (needed to make sure e/E wasn't hex first)
        return floatAST(s);
    }
    else if (tmp.charAt(0) === '0' && (tmp.charAt(1) === 'b' || tmp.charAt(1) === 'B')) {
        // Binary
        tmp = tmp.substring(2);
        value = parseInt(tmp, 2);
        radix = 2;
    }
    else if (tmp.charAt(0) === '0') {
        if (tmp === "0") {
            // Zero
            value = 0;
        }
        else {
            // Octal (Leading zero, but not actually zero)
            if (end === 'l' || end === 'L') {
                return longAST(s.substr(0, s.length - 1), 8);
            }
            else {
                radix = 8;
                tmp = tmp.substring(1);
                if ((tmp.charAt(0) === 'o') || (tmp.charAt(0) === 'O')) {
                    tmp = tmp.substring(1);
                }
                value = parseInt(tmp, 8);
            }
        }
    }
    else {
        // Decimal
        if (end === 'l' || end === 'L') {
            return longAST(s.substr(0, s.length - 1), radix);
        }
        else {
            value = parseInt(tmp, radix);
        }
    }
    // Convert to long
    if (value > LONG_THRESHOLD && Math.floor(value) === value && (s.indexOf('e') === -1 && s.indexOf('E') === -1)) {
        // TODO: Does radix zero make sense?
        return longAST(s, 0);
    }
    if (end === 'l' || end === 'L') {
        return longAST(s.substr(0, s.length - 1), radix);
    }
    else {
        if (neg) {
            return intAST(-value);
        }
        else {
            return intAST(value);
        }
    }
}
function astForSlice(c, n) {
    REQ(n, SYM.subscript);
    var ch = CHILD(n, 0);
    var lower = null;
    var upper = null;
    var step = null;
    if (ch.type === Tokens.T_DOT) {
        return new Ellipsis();
    }
    if (NCH(n) === 1 && ch.type === SYM.IfExpr) {
        return new Index(astForExpr(c, ch));
    }
    if (ch.type === SYM.IfExpr)
        lower = astForExpr(c, ch);
    if (ch.type === Tokens.T_COLON) {
        if (NCH(n) > 1) {
            var n2 = CHILD(n, 1);
            if (n2.type === SYM.IfExpr)
                upper = astForExpr(c, n2);
        }
    }
    else if (NCH(n) > 2) {
        var n2 = CHILD(n, 2);
        if (n2.type === SYM.IfExpr) {
            upper = astForExpr(c, n2);
        }
    }
    ch = CHILD(n, NCH(n) - 1);
    if (ch.type === SYM.sliceop) {
        if (NCH(ch) === 1) {
            ch = CHILD(ch, 0);
            step = new Name(strobj("None"), Load, ch.lineno, ch.col_offset);
        }
        else {
            ch = CHILD(ch, 1);
            if (ch.type === SYM.IfExpr)
                step = astForExpr(c, ch);
        }
    }
    return new Slice(lower, upper, step);
}
function astForAtomExpr(c, n) {
    var ch = CHILD(n, 0);
    switch (ch.type) {
        case Tokens.T_NAME:
            // All names start in Load context, but may be changed later
            return new Name(strobj(ch.value), Load, n.lineno, n.col_offset);
        case Tokens.T_STRING:
            return new Str(parsestrplus(c, n), n.lineno, n.col_offset);
        case Tokens.T_NUMBER:
            return new Num(parsenumber(c, ch.value, n.lineno), n.lineno, n.col_offset);
        case Tokens.T_LPAR:
            ch = CHILD(n, 1);
            if (ch.type === Tokens.T_RPAR) {
                return new Tuple([], Load, n.lineno, n.col_offset);
            }
            if (ch.type === SYM.YieldExpr) {
                return astForExpr(c, ch);
            }
            if (NCH(ch) > 1 && CHILD(ch, 1).type === SYM.gen_for) {
                return astForGenexp(c, ch);
            }
            return astForTestlistGexp(c, ch);
        case Tokens.T_LSQB:
            ch = CHILD(n, 1);
            if (ch.type === Tokens.T_RSQB)
                return new List([], Load, n.lineno, n.col_offset);
            REQ(ch, SYM.listmaker);
            if (NCH(ch) === 1 || CHILD(ch, 1).type === Tokens.T_COMMA)
                return new List(seqForTestlist(c, ch), Load, n.lineno, n.col_offset);
            else
                return astForListcomp(c, ch);
        case Tokens.T_LBRACE:
            /* dictmaker: test ':' test (',' test ':' test)* [','] */
            ch = CHILD(n, 1);
            // var size = Math.floor((NCH(ch) + 1) / 4); // + 1 for no trailing comma case
            var keys = [];
            var values = [];
            for (var i = 0; i < NCH(ch); i += 4) {
                keys[i / 4] = astForExpr(c, CHILD(ch, i));
                values[i / 4] = astForExpr(c, CHILD(ch, i + 2));
            }
            return new Dict(keys, values, n.lineno, n.col_offset);
        case Tokens.T_BACKQUOTE:
            throw syntaxError("backquote not supported, use repr()", n.lineno);
        default: {
            throw new Error("unhandled atom" /*, ch.type*/);
        }
    }
}
function astForPowerExpr(c, n) {
    REQ(n, SYM.PowerExpr);
    var e = astForAtomExpr(c, CHILD(n, 0));
    if (NCH(n) === 1)
        return e;
    for (var i = 1; i < NCH(n); ++i) {
        var ch = CHILD(n, i);
        if (ch.type !== SYM.trailer) {
            break;
        }
        var tmp = astForTrailer(c, ch, e);
        tmp.lineno = e.lineno;
        tmp.col_offset = e.col_offset;
        e = tmp;
    }
    if (CHILD(n, NCH(n) - 1).type === SYM.UnaryExpr) {
        var f = astForExpr(c, CHILD(n, NCH(n) - 1));
        return new BinOp(e, Pow, f, n.lineno, n.col_offset);
    }
    else {
        return e;
    }
}
function astForExpr(c, n) {
    LOOP: while (true) {
        switch (n.type) {
            case SYM.IfExpr:
            case SYM.old_test:
                if (CHILD(n, 0).type === SYM.LambdaExpr || CHILD(n, 0).type === SYM.old_LambdaExpr)
                    return astForLambdef(c, CHILD(n, 0));
                else if (NCH(n) > 1)
                    return astForIfexpr(c, n);
            // fallthrough
            case SYM.OrExpr:
            case SYM.AndExpr:
                if (NCH(n) === 1) {
                    n = CHILD(n, 0);
                    continue LOOP;
                }
                var seq = [];
                for (var i = 0; i < NCH(n); i += 2) {
                    seq[i / 2] = astForExpr(c, CHILD(n, i));
                }
                if (CHILD(n, 1).value === "and") {
                    return new BoolOp(And, seq, n.lineno, n.col_offset);
                }
                assert(CHILD(n, 1).value === "or");
                return new BoolOp(Or, seq, n.lineno, n.col_offset);
            case SYM.NotExpr:
                if (NCH(n) === 1) {
                    n = CHILD(n, 0);
                    continue LOOP;
                }
                else {
                    return new UnaryOp(Not, astForExpr(c, CHILD(n, 1)), n.lineno, n.col_offset);
                }
            case SYM.ComparisonExpr:
                if (NCH(n) === 1) {
                    n = CHILD(n, 0);
                    continue LOOP;
                }
                else {
                    var ops = [];
                    var cmps = [];
                    for (var i = 1; i < NCH(n); i += 2) {
                        ops[(i - 1) / 2] = astForCompOp(c, CHILD(n, i));
                        cmps[(i - 1) / 2] = astForExpr(c, CHILD(n, i + 1));
                    }
                    return new Compare(astForExpr(c, CHILD(n, 0)), ops, cmps, n.lineno, n.col_offset);
                }
            case SYM.ArithmeticExpr:
            case SYM.GeometricExpr:
            case SYM.ShiftExpr:
            case SYM.BitwiseOrExpr:
            case SYM.BitwiseXorExpr:
            case SYM.BitwiseAndExpr:
                if (NCH(n) === 1) {
                    n = CHILD(n, 0);
                    continue LOOP;
                }
                return astForBinop(c, n);
            case SYM.YieldExpr:
                var exp = null;
                if (NCH(n) === 2) {
                    exp = astForTestlist(c, CHILD(n, 1));
                }
                return new Yield(exp, n.lineno, n.col_offset);
            case SYM.UnaryExpr:
                if (NCH(n) === 1) {
                    n = CHILD(n, 0);
                    continue LOOP;
                }
                return astForUnaryExpr(c, n);
            case SYM.PowerExpr:
                return astForPowerExpr(c, n);
            default: {
                throw new Error("unhandled expr" /*, "n.type: %d", n.type*/);
            }
        }
    }
}
function astForPrintStmt(c, n) {
    var start = 1;
    var dest = null;
    REQ(n, SYM.print_stmt);
    if (NCH(n) >= 2 && CHILD(n, 1).type === Tokens.T_RIGHTSHIFT) {
        dest = astForExpr(c, CHILD(n, 2));
        start = 4;
    }
    var seq = [];
    for (var i = start, j = 0; i < NCH(n); i += 2, ++j) {
        seq[j] = astForExpr(c, CHILD(n, i));
    }
    var nl = (CHILD(n, NCH(n) - 1)).type === Tokens.T_COMMA ? false : true;
    return new Print(dest, seq, nl, n.lineno, n.col_offset);
}
function astForStmt(c, n) {
    if (n.type === SYM.stmt) {
        assert(NCH(n) === 1);
        n = CHILD(n, 0);
    }
    if (n.type === SYM.simple_stmt) {
        assert(numStmts(n) === 1);
        n = CHILD(n, 0);
    }
    if (n.type === SYM.small_stmt) {
        REQ(n, SYM.small_stmt);
        n = CHILD(n, 0);
        switch (n.type) {
            case SYM.ExprStmt: return astForExprStmt(c, n);
            case SYM.print_stmt: return astForPrintStmt(c, n);
            case SYM.del_stmt: return astForDelStmt(c, n);
            case SYM.pass_stmt: return new Pass(n.lineno, n.col_offset);
            case SYM.flow_stmt: return astForFlowStmt(c, n);
            case SYM.import_stmt: return astForImportStmt(c, n);
            case SYM.GlobalStmt: return astForGlobalStmt(c, n);
            case SYM.NonLocalStmt: return astForNonLocalStmt(c, n);
            case SYM.exec_stmt: return astForExecStmt(c, n);
            case SYM.assert_stmt: return astForAssertStmt(c, n);
            default: {
                throw new Error("unhandled small_stmt");
            }
        }
    }
    else {
        var ch = CHILD(n, 0);
        REQ(n, SYM.compound_stmt);
        switch (ch.type) {
            case SYM.if_stmt: return astForIfStmt(c, ch);
            case SYM.while_stmt: return astForWhileStmt(c, ch);
            case SYM.for_stmt: return astForForStmt(c, ch);
            case SYM.try_stmt: return astForTryStmt(c, ch);
            case SYM.with_stmt: return astForWithStmt(c, ch);
            case SYM.funcdef: return astForFuncdef(c, ch, []);
            case SYM.classdef: return astForClassdef(c, ch, []);
            case SYM.decorated: return astForDecorated(c, ch);
            default: {
                throw new Error("unhandled compound_stmt");
            }
        }
    }
}
function astFromParse(n) {
    var c = new Compiling("utf-8");
    var stmts = [];
    var k = 0;
    switch (n.type) {
        case SYM.file_input:
            for (var i = 0; i < NCH(n) - 1; ++i) {
                var ch = CHILD(n, i);
                if (n.type === Tokens.T_NEWLINE)
                    continue;
                REQ(ch, SYM.stmt);
                var num = numStmts(ch);
                if (num === 1) {
                    stmts[k++] = astForStmt(c, ch);
                }
                else {
                    ch = CHILD(ch, 0);
                    REQ(ch, SYM.simple_stmt);
                    for (var j = 0; j < num; ++j) {
                        stmts[k++] = astForStmt(c, CHILD(ch, j * 2));
                    }
                }
            }
            return new Module(stmts);
        case SYM.eval_input: {
            throw new Error("todo;");
        }
        case SYM.single_input: {
            throw new Error("todo;");
        }
        default: {
            throw new Error("todo;");
        }
    }
}
function astDump(node) {
    var _format = function (node) {
        if (node === null) {
            return "None";
        }
        else if (node.prototype && node.prototype._astname !== undefined && node.prototype._isenum) {
            return node.prototype._astname + "()";
        }
        else if (node._astname !== undefined) {
            var fields = [];
            for (var i = 0; i < node._fields.length; i += 2) {
                var a = node._fields[i]; // field name
                var b = node._fields[i + 1](node); // field getter func
                fields.push([a, _format(b)]);
            }
            var attrs = [];
            for (var i = 0; i < fields.length; ++i) {
                var field = fields[i];
                attrs.push(field[0] + "=" + field[1].replace(/^\s+/, ''));
            }
            var fieldstr = attrs.join(',');
            return node._astname + "(" + fieldstr + ")";
        }
        else if (isArrayLike(node)) {
            var elems = [];
            for (var i = 0; i < node.length; ++i) {
                var x = node[i];
                elems.push(_format(x));
            }
            var elemsstr = elems.join(',');
            return "[" + elemsstr.replace(/^\s+/, '') + "]";
        }
        else {
            var ret = void 0;
            if (node === true)
                ret = "True";
            else if (node === false)
                ret = "False";
            else
                ret = "" + node;
            return ret;
        }
    };
    return _format(node);
}

/**
 * TODO: Reserved for whom?
 */
/**
 * TODO: Reserved for whom?
 */ var reservedNames = {
    '__defineGetter__': true,
    '__defineSetter__': true,
    'apply': true,
    'call': true,
    'eval': true,
    'hasOwnProperty': true,
    'isPrototypeOf': true,
    '__lookupGetter__': true,
    '__lookupSetter__': true,
    '__noSuchMethod__': true,
    'propertyIsEnumerable': true,
    'toSource': true,
    'toLocaleString': true,
    'toString': true,
    'unwatch': true,
    'valueOf': true,
    'watch': true,
    'length': true
};

/**
 * TODO: Reserved for whom?
 */
/**
 * TODO: Reserved for whom?
 */ var reservedWords = {
    'abstract': true,
    'as': true,
    'boolean': true,
    'break': true,
    'byte': true,
    'case': true,
    'catch': true,
    'char': true,
    'class': true,
    'continue': true,
    'const': true,
    'debugger': true,
    'default': true,
    'delete': true,
    'do': true,
    'double': true,
    'else': true,
    'enum': true,
    'export': true,
    'extends': true,
    'false': true,
    'final': true,
    'finally': true,
    'float': true,
    'for': true,
    'function': true,
    'goto': true,
    'if': true,
    'implements': true,
    'import': true,
    'in': true,
    'instanceof': true,
    'int': true,
    'interface': true,
    'is': true,
    'long': true,
    'namespace': true,
    'native': true,
    'new': true,
    'null': true,
    'package': true,
    'private': true,
    'protected': true,
    'public': true,
    'return': true,
    'short': true,
    'static': true,
    'super': false,
    'switch': true,
    'synchronized': true,
    'this': true,
    'throw': true,
    'throws': true,
    'transient': true,
    'true': true,
    'try': true,
    'typeof': true,
    'use': true,
    'var': true,
    'void': true,
    'volatile': true,
    'while': true,
    'with': true
};

function dictUpdate(a, b) {
    for (var kb in b) {
        if (b.hasOwnProperty(kb)) {
            a[kb] = b[kb];
        }
    }
}

/**
 * @param {string|null} priv
 * @param {string} name
 */
/**
 * @param {string|null} priv
 * @param {string} name
 */ function mangleName$1(priv, name) {
    var strpriv = null;
    if (priv === null || name === null || name.charAt(0) !== '_' || name.charAt(1) !== '_')
        return name;
    // don't mangle __id__
    if (name.charAt(name.length - 1) === '_' && name.charAt(name.length - 2) === '_')
        return name;
    // don't mangle classes that are all _ (obscure much?)
    strpriv = priv;
    strpriv.replace(/_/g, '');
    if (strpriv === '')
        return name;
    strpriv = priv;
    strpriv.replace(/^_*/, '');
    strpriv = '_' + strpriv + name;
    return strpriv;
}

/* Flags for def-use information */
/* Flags for def-use information */ var DEF_GLOBAL = 1; /* global stmt */
/* global stmt */ var DEF_LOCAL = 2; /* assignment in code block */
/* assignment in code block */ var DEF_PARAM = 2 << 1; /* formal parameter */
/* formal parameter */ var USE = 2 << 2; /* name is used */
/* name is used */  /* parameter is star arg */
/* parameter is star arg */  /* parameter is star-star arg */
/* parameter is star-star arg */  /* name defined in tuple in parameters */
/* name defined in tuple in parameters */  /* name used but not defined in nested block */
/* name used but not defined in nested block */  /* free variable is actually implicit global */
/* free variable is actually implicit global */ var DEF_FREE_CLASS = 2 << 8; /* free variable from class's method */
/* free variable from class's method */ var DEF_IMPORT = 2 << 9; /* assignment occurred via import */
/* assignment occurred via import */ var DEF_BOUND = (DEF_LOCAL | DEF_PARAM | DEF_IMPORT);
/* GLOBAL_EXPLICIT and GLOBAL_IMPLICIT are used internally by the symbol
   table.  GLOBAL is returned from PyST_GetScope() for either of them.
   It is stored in ste_symbols at bits 12-14.
*/
var SCOPE_OFF = 11;
var SCOPE_MASK = 7;
var LOCAL = 1;
var GLOBAL_EXPLICIT = 2;
var GLOBAL_IMPLICIT = 3;
var FREE = 4;
var CELL = 5;
/* The following three names are used for the ste_unoptimized bit field */



 /* top-level names, including eval and exec */
/* top-level names, including eval and exec */ 

var ModuleBlock = 'module';
var FunctionBlock = 'function';
var ClassBlock = 'class';

var Symbol$1 = (function () {
    /**
     * @param name
     * @param flags
     * @param namespaces
     */
    function Symbol(name, flags, namespaces) {
        this.__name = name;
        this.__flags = flags;
        this.__scope = (flags >> SCOPE_OFF) & SCOPE_MASK;
        this.__namespaces = namespaces || [];
    }
    Symbol.prototype.get_name = function () { return this.__name; };
    Symbol.prototype.is_referenced = function () { return !!(this.__flags & USE); };
    Symbol.prototype.is_parameter = function () {
        return !!(this.__flags & DEF_PARAM);
    };
    Symbol.prototype.is_global = function () {
        return this.__scope === GLOBAL_IMPLICIT || this.__scope === GLOBAL_EXPLICIT;
    };
    Symbol.prototype.is_declared_global = function () {
        return this.__scope === GLOBAL_EXPLICIT;
    };
    Symbol.prototype.is_local = function () {
        return !!(this.__flags & DEF_BOUND);
    };
    Symbol.prototype.is_free = function () { return this.__scope === FREE; };
    Symbol.prototype.is_imported = function () { return !!(this.__flags & DEF_IMPORT); };
    Symbol.prototype.is_assigned = function () { return !!(this.__flags & DEF_LOCAL); };
    Symbol.prototype.is_namespace = function () { return this.__namespaces && this.__namespaces.length > 0; };
    Symbol.prototype.get_namespaces = function () { return this.__namespaces; };
    return Symbol;
}());

var astScopeCounter = 0;
var SymbolTableScope = (function () {
    /**
     * @param table
     * @param name
     * @param type
     * @param lineno
     */
    function SymbolTableScope(table, name, blockType, ast, lineno) {
        this.symFlags = {};
        this.name = name;
        this.varnames = [];
        /**
         *
         */
        this.children = [];
        this.blockType = blockType;
        this.isNested = false;
        this.hasFree = false;
        this.childHasFree = false; // true if child block has free vars including free refs to globals
        this.generator = false;
        this.varargs = false;
        this.varkeywords = false;
        this.returnsValue = false;
        this.lineno = lineno;
        this.table = table;
        if (table.cur && (table.cur.isNested || table.cur.blockType === FunctionBlock))
            this.isNested = true;
        ast.scopeId = astScopeCounter++;
        table.stss[ast.scopeId] = this;
        // cache of Symbols for returning to other parts of code
        this.symbols = {};
    }
    SymbolTableScope.prototype.get_type = function () { return this.blockType; };
    SymbolTableScope.prototype.get_name = function () { return this.name; };
    SymbolTableScope.prototype.get_lineno = function () { return this.lineno; };
    SymbolTableScope.prototype.is_nested = function () { return this.isNested; };
    SymbolTableScope.prototype.has_children = function () { return this.children.length > 0; };
    SymbolTableScope.prototype.get_identifiers = function () { return this._identsMatching(function (x) { return true; }); };
    SymbolTableScope.prototype.lookup = function (name) {
        var sym;
        if (!this.symbols.hasOwnProperty(name)) {
            var flags = this.symFlags[name];
            var namespaces = this.__check_children(name);
            sym = this.symbols[name] = new Symbol$1(name, flags, namespaces);
        }
        else {
            sym = this.symbols[name];
        }
        return sym;
    };
    SymbolTableScope.prototype.__check_children = function (name) {
        // print("  check_children:", name);
        var ret = [];
        for (var i = 0; i < this.children.length; ++i) {
            var child = this.children[i];
            if (child.name === name)
                ret.push(child);
        }
        return ret;
    };
    SymbolTableScope.prototype._identsMatching = function (f) {
        var ret = [];
        for (var k in this.symFlags) {
            if (this.symFlags.hasOwnProperty(k)) {
                if (f(this.symFlags[k]))
                    ret.push(k);
            }
        }
        ret.sort();
        return ret;
    };
    SymbolTableScope.prototype.get_parameters = function () {
        assert(this.get_type() === 'function', "get_parameters only valid for function scopes");
        if (!this._funcParams)
            this._funcParams = this._identsMatching(function (x) { return !!(x & DEF_PARAM); });
        return this._funcParams;
    };
    SymbolTableScope.prototype.get_locals = function () {
        assert(this.get_type() === 'function', "get_locals only valid for function scopes");
        if (!this._funcLocals)
            this._funcLocals = this._identsMatching(function (x) { return !!(x & DEF_BOUND); });
        return this._funcLocals;
    };
    SymbolTableScope.prototype.get_globals = function () {
        assert(this.get_type() === 'function', "get_globals only valid for function scopes");
        if (!this._funcGlobals) {
            this._funcGlobals = this._identsMatching(function (x) {
                var masked = (x >> SCOPE_OFF) & SCOPE_MASK;
                return masked === GLOBAL_IMPLICIT || masked === GLOBAL_EXPLICIT;
            });
        }
        return this._funcGlobals;
    };
    SymbolTableScope.prototype.get_frees = function () {
        assert(this.get_type() === 'function', "get_frees only valid for function scopes");
        if (!this._funcFrees) {
            this._funcFrees = this._identsMatching(function (x) {
                var masked = (x >> SCOPE_OFF) & SCOPE_MASK;
                return masked === FREE;
            });
        }
        return this._funcFrees;
    };
    SymbolTableScope.prototype.get_methods = function () {
        assert(this.get_type() === 'class', "get_methods only valid for class scopes");
        if (!this._classMethods) {
            // todo; uniq?
            var all = [];
            for (var i = 0; i < this.children.length; ++i)
                all.push(this.children[i].name);
            all.sort();
            this._classMethods = all;
        }
        return this._classMethods;
    };
    SymbolTableScope.prototype.getScope = function (name) {
        // print("getScope");
        // for (var k in this.symFlags) print(k);
        var v = this.symFlags[name];
        if (v === undefined)
            return 0;
        return (v >> SCOPE_OFF) & SCOPE_MASK;
    };
    return SymbolTableScope;
}());

/**
 * @param message
 * @param lineNumber
 */
function syntaxError$1(message, lineNumber) {
    assert(isString(message), "message must be a string");
    if (isDef(lineNumber)) {
        assert(isNumber(lineNumber), "lineNumber must be a number");
    }
    var e = new SyntaxError(message /*, fileName*/);
    if (typeof lineNumber === 'number') {
        e['lineNumber'] = lineNumber;
    }
    return e;
}

/**
 * The symbol table uses the abstract synntax tree (not the parse tree).
 */
var SymbolTable = (function () {
    /**
     *
     */
    function SymbolTable() {
        this.cur = null;
        this.top = null;
        this.stack = [];
        this.global = null; // points at top level module symFlags
        this.curClass = null; // current class or null
        this.tmpname = 0;
        // mapping from ast nodes to their scope if they have one. we add an
        // id to the ast node when a scope is created for it, and store it in
        // here for the compiler to lookup later.
        this.stss = {};
    }
    /**
     * Lookup the SymbolTableScope for a scopeId of the AST.
     */
    SymbolTable.prototype.getStsForAst = function (ast) {
        assert(ast.scopeId !== undefined, "ast wasn't added to st?");
        var v = this.stss[ast.scopeId];
        assert(v !== undefined, "unknown sym tab entry");
        return v;
    };
    SymbolTable.prototype.SEQStmt = function (nodes) {
        var len = nodes.length;
        for (var i = 0; i < len; ++i) {
            var val = nodes[i];
            if (val)
                this.visitStmt(val);
        }
    };
    SymbolTable.prototype.SEQExpr = function (nodes) {
        var len = nodes.length;
        for (var i = 0; i < len; ++i) {
            var val = nodes[i];
            if (val)
                this.visitExpr(val);
        }
    };
    SymbolTable.prototype.enterBlock = function (name, blockType, ast, lineno) {
        //  name = fixReservedNames(name);
        var prev = null;
        if (this.cur) {
            prev = this.cur;
            this.stack.push(this.cur);
        }
        this.cur = new SymbolTableScope(this, name, blockType, ast, lineno);
        if (name === 'top') {
            this.global = this.cur.symFlags;
        }
        if (prev) {
            prev.children.push(this.cur);
        }
    };
    SymbolTable.prototype.exitBlock = function () {
        // print("exitBlock");
        this.cur = null;
        if (this.stack.length > 0)
            this.cur = this.stack.pop();
    };
    SymbolTable.prototype.visitParams = function (args, toplevel) {
        for (var i = 0; i < args.length; ++i) {
            var arg = args[i];
            if (arg.constructor === Name) {
                assert(arg.ctx === Param || (arg.ctx === Store && !toplevel));
                this.addDef(arg.id, DEF_PARAM, arg.lineno);
            }
            else {
                // Tuple isn't supported
                throw syntaxError$1("invalid expression in parameter list");
            }
        }
    };
    SymbolTable.prototype.visitArguments = function (a, lineno) {
        if (a.args)
            this.visitParams(a.args, true);
        if (a.vararg) {
            this.addDef(a.vararg, DEF_PARAM, lineno);
            this.cur.varargs = true;
        }
        if (a.kwarg) {
            this.addDef(a.kwarg, DEF_PARAM, lineno);
            this.cur.varkeywords = true;
        }
    };
    /**
     * @param {number} lineno
     * @return {void}
     */
    SymbolTable.prototype.newTmpname = function (lineno) {
        this.addDef("_[" + (++this.tmpname) + "]", DEF_LOCAL, lineno);
    };
    /**
     * @param {string} name
     * @param {number} flag
     * @param {number} lineno
     * @return {void}
     */
    SymbolTable.prototype.addDef = function (name, flag, lineno) {
        var mangled = mangleName$1(this.curClass, name);
        //  mangled = fixReservedNames(mangled);
        var val = this.cur.symFlags[mangled];
        if (val !== undefined) {
            if ((flag & DEF_PARAM) && (val & DEF_PARAM)) {
                throw syntaxError$1("duplicate argument '" + name + "' in function definition", lineno);
            }
            val |= flag;
        }
        else {
            val = flag;
        }
        this.cur.symFlags[mangled] = val;
        if (flag & DEF_PARAM) {
            this.cur.varnames.push(mangled);
        }
        else if (flag & DEF_GLOBAL) {
            val = flag;
            var fromGlobal = this.global[mangled];
            if (fromGlobal !== undefined)
                val |= fromGlobal;
            this.global[mangled] = val;
        }
    };
    SymbolTable.prototype.visitSlice = function (s) {
        if (s instanceof Slice) {
            if (s.lower)
                this.visitExpr(s.lower);
            if (s.upper)
                this.visitExpr(s.upper);
            if (s.step)
                this.visitExpr(s.step);
        }
        else if (s instanceof ExtSlice) {
            for (var i = 0; i < s.dims.length; ++i) {
                this.visitSlice(s.dims[i]);
            }
        }
        else if (s instanceof Index) {
            this.visitExpr(s.value);
        }
        else if (s instanceof Ellipsis) {
            // Do nothing.
        }
    };
    /**
     * @param {Object} s
     */
    SymbolTable.prototype.visitStmt = function (s) {
        assert(s !== undefined, "visitStmt called with undefined");
        if (s instanceof FunctionDef) {
            this.addDef(s.name, DEF_LOCAL, s.lineno);
            if (s.args.defaults)
                this.SEQExpr(s.args.defaults);
            if (s.decorator_list)
                this.SEQExpr(s.decorator_list);
            this.enterBlock(s.name, FunctionBlock, s, s.lineno);
            this.visitArguments(s.args, s.lineno);
            this.SEQStmt(s.body);
            this.exitBlock();
        }
        else if (s instanceof ClassDef) {
            this.addDef(s.name, DEF_LOCAL, s.lineno);
            this.SEQExpr(s.bases);
            if (s.decorator_list)
                this.SEQExpr(s.decorator_list);
            this.enterBlock(s.name, ClassBlock, s, s.lineno);
            var tmp = this.curClass;
            this.curClass = s.name;
            this.SEQStmt(s.body);
            this.curClass = tmp;
            this.exitBlock();
        }
        else if (s instanceof ReturnStatement) {
            if (s.value) {
                this.visitExpr(s.value);
                this.cur.returnsValue = true;
                if (this.cur.generator) {
                    throw syntaxError$1("'return' with argument inside generator");
                }
            }
        }
        else if (s instanceof DeleteExpression) {
            this.SEQExpr(s.targets);
        }
        else if (s instanceof Assign) {
            this.SEQExpr(s.targets);
            this.visitExpr(s.value);
        }
        else if (s instanceof AugAssign) {
            this.visitExpr(s.target);
            this.visitExpr(s.value);
        }
        else if (s instanceof Print) {
            if (s.dest)
                this.visitExpr(s.dest);
            this.SEQExpr(s.values);
        }
        else if (s instanceof ForStatement) {
            this.visitExpr(s.target);
            this.visitExpr(s.iter);
            this.SEQStmt(s.body);
            if (s.orelse)
                this.SEQStmt(s.orelse);
        }
        else if (s instanceof WhileStatement) {
            this.visitExpr(s.test);
            this.SEQStmt(s.body);
            if (s.orelse)
                this.SEQStmt(s.orelse);
        }
        else if (s instanceof IfStatement) {
            this.visitExpr(s.test);
            this.SEQStmt(s.consequent);
            if (s.alternate) {
                this.SEQStmt(s.alternate);
            }
        }
        else if (s instanceof Raise) {
            if (s.type) {
                this.visitExpr(s.type);
                if (s.inst) {
                    this.visitExpr(s.inst);
                    if (s.tback)
                        this.visitExpr(s.tback);
                }
            }
        }
        else if (s instanceof TryExcept) {
            this.SEQStmt(s.body);
            this.SEQStmt(s.orelse);
            this.visitExcepthandlers(s.handlers);
        }
        else if (s instanceof TryFinally) {
            this.SEQStmt(s.body);
            this.SEQStmt(s.finalbody);
        }
        else if (s instanceof Assert) {
            this.visitExpr(s.test);
            if (s.msg)
                this.visitExpr(s.msg);
        }
        else if (s instanceof ImportStatement) {
            var imps = s;
            this.visitAlias(imps.names, imps.lineno);
        }
        else if (s instanceof ImportFrom) {
            var impFrom = s;
            this.visitAlias(impFrom.names, impFrom.lineno);
        }
        else if (s instanceof Exec) {
            this.visitExpr(s.body);
            if (s.globals) {
                this.visitExpr(s.globals);
                if (s.locals)
                    this.visitExpr(s.locals);
            }
        }
        else if (s instanceof Global) {
            var nameslen = s.names.length;
            for (var i = 0; i < nameslen; ++i) {
                var name_1 = mangleName$1(this.curClass, s.names[i]);
                //              name = fixReservedNames(name);
                var cur = this.cur.symFlags[name_1];
                if (cur & (DEF_LOCAL | USE)) {
                    if (cur & DEF_LOCAL) {
                        throw syntaxError$1("name '" + name_1 + "' is assigned to before global declaration", s.lineno);
                    }
                    else {
                        throw syntaxError$1("name '" + name_1 + "' is used prior to global declaration", s.lineno);
                    }
                }
                this.addDef(name_1, DEF_GLOBAL, s.lineno);
            }
        }
        else if (s instanceof Expr) {
            this.visitExpr(s.value);
        }
        else if (s instanceof Pass || s instanceof BreakStatement || s instanceof ContinueStatement) {
            // Do nothing.
        }
        else if (s instanceof WithStatement) {
            var ws = s;
            this.newTmpname(ws.lineno);
            this.visitExpr(ws.context_expr);
            if (ws.optional_vars) {
                this.newTmpname(ws.lineno);
                this.visitExpr(ws.optional_vars);
            }
            this.SEQStmt(ws.body);
        }
        else {
            fail("Unhandled type " + s.constructor.name + " in visitStmt");
        }
    };
    SymbolTable.prototype.visitExpr = function (e) {
        assert(e !== undefined, "visitExpr called with undefined");
        if (e instanceof BoolOp) {
            this.SEQExpr(e.values);
        }
        else if (e instanceof BinOp) {
            this.visitExpr(e.left);
            this.visitExpr(e.right);
        }
        else if (e instanceof UnaryOp) {
            this.visitExpr(e.operand);
        }
        else if (e instanceof Lambda) {
            this.addDef("lambda", DEF_LOCAL, e.lineno);
            if (e.args.defaults)
                this.SEQExpr(e.args.defaults);
            this.enterBlock("lambda", FunctionBlock, e, e.lineno);
            this.visitArguments(e.args, e.lineno);
            this.visitExpr(e.body);
            this.exitBlock();
        }
        else if (e instanceof IfExp) {
            this.visitExpr(e.test);
            this.visitExpr(e.body);
            this.visitExpr(e.orelse);
        }
        else if (e instanceof Dict) {
            this.SEQExpr(e.keys);
            this.SEQExpr(e.values);
        }
        else if (e instanceof ListComp) {
            this.newTmpname(e.lineno);
            this.visitExpr(e.elt);
            this.visitComprehension(e.generators, 0);
        }
        else if (e instanceof GeneratorExp) {
            this.visitGenexp(e);
        }
        else if (e instanceof Yield) {
            if (e.value)
                this.visitExpr(e.value);
            this.cur.generator = true;
            if (this.cur.returnsValue) {
                throw syntaxError$1("'return' with argument inside generator");
            }
        }
        else if (e instanceof Compare) {
            this.visitExpr(e.left);
            this.SEQExpr(e.comparators);
        }
        else if (e instanceof Call) {
            this.visitExpr(e.func);
            this.SEQExpr(e.args);
            for (var i = 0; i < e.keywords.length; ++i)
                this.visitExpr(e.keywords[i].value);
            // print(JSON.stringify(e.starargs, null, 2));
            // print(JSON.stringify(e.kwargs, null,2));
            if (e.starargs)
                this.visitExpr(e.starargs);
            if (e.kwargs)
                this.visitExpr(e.kwargs);
        }
        else if (e instanceof Num || e instanceof Str) {
            // Do nothing.
        }
        else if (e instanceof Attribute) {
            this.visitExpr(e.value);
        }
        else if (e instanceof Subscript) {
            this.visitExpr(e.value);
            this.visitSlice(e.slice);
        }
        else if (e instanceof Name) {
            this.addDef(e.id, e.ctx === Load ? USE : DEF_LOCAL, e.lineno);
        }
        else if (e instanceof List || e instanceof Tuple) {
            this.SEQExpr(e.elts);
        }
        else {
            fail("Unhandled type " + e.constructor.name + " in visitExpr");
        }
    };
    SymbolTable.prototype.visitComprehension = function (lcs, startAt) {
        var len = lcs.length;
        for (var i = startAt; i < len; ++i) {
            var lc = lcs[i];
            this.visitExpr(lc.target);
            this.visitExpr(lc.iter);
            this.SEQExpr(lc.ifs);
        }
    };
    /**
     * This is probably not correct for names. What are they?
     * @param {Array.<Object>} names
     * @param {number} lineno
     */
    SymbolTable.prototype.visitAlias = function (names, lineno) {
        /* Compute store_name, the name actually bound by the import
            operation.  It is diferent than a->name when a->name is a
            dotted package name (e.g. spam.eggs)
        */
        for (var i = 0; i < names.length; ++i) {
            var a = names[i];
            // DGH: The RHS used to be Python strings.
            var name_2 = a.asname === null ? a.name : a.asname;
            var storename = name_2;
            var dot = name_2.indexOf('.');
            if (dot !== -1)
                storename = name_2.substr(0, dot);
            if (name_2 !== "*") {
                this.addDef(storename, DEF_IMPORT, lineno);
            }
            else {
                if (this.cur.blockType !== ModuleBlock) {
                    throw syntaxError$1("import * only allowed at module level");
                }
            }
        }
    };
    /**
     *
     */
    SymbolTable.prototype.visitGenexp = function (e) {
        var outermost = e.generators[0];
        // outermost is evaled in current scope
        this.visitExpr(outermost.iter);
        this.enterBlock("genexpr", FunctionBlock, e, e.lineno);
        this.cur.generator = true;
        this.addDef(".0", DEF_PARAM, e.lineno);
        this.visitExpr(outermost.target);
        this.SEQExpr(outermost.ifs);
        this.visitComprehension(e.generators, 1);
        this.visitExpr(e.elt);
        this.exitBlock();
    };
    SymbolTable.prototype.visitExcepthandlers = function (handlers) {
        for (var i = 0, eh = void 0; eh = handlers[i]; ++i) {
            if (eh.type)
                this.visitExpr(eh.type);
            if (eh.name)
                this.visitExpr(eh.name);
            this.SEQStmt(eh.body);
        }
    };
    /**
     * @param ste The Symbol Table Scope.
     */
    SymbolTable.prototype.analyzeBlock = function (ste, bound, free, global) {
        var local = {};
        var scope = {};
        var newglobal = {};
        var newbound = {};
        var newfree = {};
        if (ste.blockType === ClassBlock) {
            dictUpdate(newglobal, global);
            if (bound)
                dictUpdate(newbound, bound);
        }
        for (var name_3 in ste.symFlags) {
            if (ste.symFlags.hasOwnProperty(name_3)) {
                var flags = ste.symFlags[name_3];
                this.analyzeName(ste, scope, name_3, flags, bound, local, free, global);
            }
        }
        if (ste.blockType !== ClassBlock) {
            if (ste.blockType === FunctionBlock)
                dictUpdate(newbound, local);
            if (bound)
                dictUpdate(newbound, bound);
            dictUpdate(newglobal, global);
        }
        var allfree = {};
        var childlen = ste.children.length;
        for (var i = 0; i < childlen; ++i) {
            var c = ste.children[i];
            this.analyzeChildBlock(c, newbound, newfree, newglobal, allfree);
            if (c.hasFree || c.childHasFree)
                ste.childHasFree = true;
        }
        dictUpdate(newfree, allfree);
        if (ste.blockType === FunctionBlock)
            this.analyzeCells(scope, newfree);
        this.updateSymbols(ste.symFlags, scope, bound, newfree, ste.blockType === ClassBlock);
        dictUpdate(free, newfree);
    };
    SymbolTable.prototype.analyzeChildBlock = function (entry, bound, free, global, childFree) {
        var tempBound = {};
        dictUpdate(tempBound, bound);
        var tempFree = {};
        dictUpdate(tempFree, free);
        var tempGlobal = {};
        dictUpdate(tempGlobal, global);
        this.analyzeBlock(entry, tempBound, tempFree, tempGlobal);
        dictUpdate(childFree, tempFree);
    };
    SymbolTable.prototype.analyzeCells = function (scope, free) {
        for (var name_4 in scope) {
            if (scope.hasOwnProperty(name_4)) {
                var flags = scope[name_4];
                if (flags !== LOCAL)
                    continue;
                if (free[name_4] === undefined)
                    continue;
                scope[name_4] = CELL;
                delete free[name_4];
            }
        }
    };
    /**
     * store scope info back into the st symbols dict. symbols is modified,
     * others are not.
     */
    SymbolTable.prototype.updateSymbols = function (symbols, scope, bound, free, classflag) {
        for (var name_5 in symbols) {
            if (symbols.hasOwnProperty(name_5)) {
                var flags = symbols[name_5];
                var w = scope[name_5];
                flags |= w << SCOPE_OFF;
                symbols[name_5] = flags;
            }
        }
        var freeValue = FREE << SCOPE_OFF;
        for (var name_6 in free) {
            if (free.hasOwnProperty(name_6)) {
                var o = symbols[name_6];
                if (o !== undefined) {
                    // it could be a free variable in a method of the class that has
                    // the same name as a local or global in the class scope
                    if (classflag && (o & (DEF_BOUND | DEF_GLOBAL))) {
                        var i = o | DEF_FREE_CLASS;
                        symbols[name_6] = i;
                    }
                    // else it's not free, probably a cell
                    continue;
                }
                if (bound[name_6] === undefined)
                    continue;
                symbols[name_6] = freeValue;
            }
        }
    };
    /**
     * @param {Object} ste The Symbol Table Scope.
     * @param {string} name
     */
    SymbolTable.prototype.analyzeName = function (ste, dict, name, flags, bound, local, free, global) {
        if (flags & DEF_GLOBAL) {
            if (flags & DEF_PARAM)
                throw syntaxError$1("name '" + name + "' is local and global", ste.lineno);
            dict[name] = GLOBAL_EXPLICIT;
            global[name] = null;
            if (bound && bound[name] !== undefined)
                delete bound[name];
            return;
        }
        if (flags & DEF_BOUND) {
            dict[name] = LOCAL;
            local[name] = null;
            delete global[name];
            return;
        }
        if (bound && bound[name] !== undefined) {
            dict[name] = FREE;
            ste.hasFree = true;
            free[name] = null;
        }
        else if (global && global[name] !== undefined) {
            dict[name] = GLOBAL_IMPLICIT;
        }
        else {
            if (ste.isNested)
                ste.hasFree = true;
            dict[name] = GLOBAL_IMPLICIT;
        }
    };
    SymbolTable.prototype.analyze = function () {
        var free = {};
        var global = {};
        this.analyzeBlock(this.top, null, free, global);
    };
    return SymbolTable;
}());

// import { Symbol } from './Symbol';
/**
 * @param ast
 * @param fileName
 */
function symbolTable(ast) {
    var st = new SymbolTable();
    st.enterBlock("top", ModuleBlock, ast, 0);
    st.top = st.cur;
    // This is a good place to dump the AST for debugging.
    for (var i = 0; i < ast.body.length; ++i) {
        st.visitStmt(ast.body[i]);
    }
    st.exitBlock();
    st.analyze();
    return st;
}
/**
 * @param st
 */

/**
 * FIXME: Argument should be declared as string but not allowed by TypeScript compiler.
 * May be a bug when comparing to 0x7f below.
 */
/**
 * FIXME: Argument should be declared as string but not allowed by TypeScript compiler.
 * May be a bug when comparing to 0x7f below.
 */

/// <reference path = "../../node_modules/typescript/lib/typescriptServices.d.ts" />
// const S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT;
// const S_FFFF = 0x00;
// const S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX;
// const S_TTFF = F_ALLOW_IN | F_FUNC_BODY;
/**
 * The output function is scoped at the module level so that it is available without being a parameter.
 * @param {...*} x
 */
var out;
/**
 * We keep track of how many time gensym method on the Compiler is called because ... ?
 */
var gensymCount = 0;
/**
 * FIXME: CompilerUnit is coupled to this module by the out variable.
 */
var CompilerUnit = (function () {
    /**
     * @constructor
     *
     * Stuff that changes on entry/exit of code blocks. must be saved and restored
     * when returning to a block.
     *
     * Corresponds to the body of a module, class, or function.
     */
    function CompilerUnit() {
        /**
         * @type {?Object}
         */
        this.ste = null;
        this.name = null;
        this.private_ = null;
        this.firstlineno = 0;
        this.lineno = 0;
        this.linenoSet = false;
        this.localnames = [];
        this.blocknum = 0;
        this.blocks = [];
        this.curblock = 0;
        this.scopename = null;
        this.prefixCode = '';
        this.varDeclsCode = '';
        this.switchCode = '';
        this.suffixCode = '';
        // stack of where to go on a break
        this.breakBlocks = [];
        // stack of where to go on a continue
        this.continueBlocks = [];
        this.exceptBlocks = [];
        this.finallyBlocks = [];
    }
    CompilerUnit.prototype.activateScope = function () {
        // The 'arguments' object cannot be referenced in an arrow function in ES3 and ES5.
        // That's why we use a standard function expression.
        var self = this;
        out = function () {
            var b = self.blocks[self.curblock];
            for (var i = 0; i < arguments.length; ++i)
                b.push(arguments[i]);
        };
    };
    return CompilerUnit;
}());
/**
 * Appends "_$rw$" to any word that is in the list of reserved words.
 */
function fixReservedWords(word) {
    if (reservedWords[word] !== true) {
        return word;
    }
    return word + "_$rw$";
}
/**
 * Appends "_$rn$" to any name that is in the list of reserved names.
 */
function fixReservedNames(name) {
    if (reservedNames[name])
        return name + "_$rn$";
    return name;
}
/**
 *
 */
function compile(source, fileName) {
    var resultFile = ts.createSourceFile(fileName, "", ts.ScriptTarget.Latest, /*setParentNodes*/ false, ts.ScriptKind.TS);
    var printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
    var code = printer.printNode(ts.EmitHint.Unspecified, transpile(source), resultFile);
    return { code: code };
}
function resetCompiler() {
    gensymCount = 0;
}
/**
 * Transpiles from Python to JavaScript.
 */
var Transpiler = (function () {
    function Transpiler(st, flags, sourceCodeForAnnotation) {
        this.st = st;
        this.flags = flags;
        this.interactive = false;
        this.nestlevel = 0;
        this.u = null;
        this.stack = [];
        this.result = [];
        // this.gensymcount = 0;
        this.allUnits = [];
        this.source = sourceCodeForAnnotation ? sourceCodeForAnnotation.split("\n") : false;
    }
    Transpiler.prototype.module = function (ast, flags) {
        // const node: ts.Node = new Node();
        var body = this.statementList(ast.body, flags);
        return ts.createModuleBlock(body);
        // node.finishProgram(body);
        // return node;
        // throw new Error(`TODO: module`);
    };
    Transpiler.prototype.statementList = function (stmts, flags) {
        var nodes = [];
        var iLen = stmts.length;
        for (var i = 0; i < iLen; i++) {
            var stmt = stmts[i];
            nodes.push(this.statement(stmt, flags));
        }
        return nodes;
    };
    Transpiler.prototype.statement = function (s, flags) {
        // this.u.lineno = s.lineno;
        // this.u.linenoSet = false;
        // this.annotateSource(s);
        if (s instanceof Expr) {
            return ts.createReturn(this.expr(s, flags));
        }
        switch (s.constructor) {
            /*
            case FunctionDef:
                return this.functionDef(s, flags);
            case ClassDef:
                return this.classDef(s, flags);
            case ReturnStatement: {
                return this.returnStatement(<ReturnStatement>s, flags);
            }
            case DeleteExpression:
                return this.deleteExpression((<DeleteExpression>s), flags);
            case Assign: {
                return this.assign(<Assign>s, flags);
            }
            case AugAssign: {
                return this.augAssign(<AugAssign>s, flags);
            }
            case Print: {
                this.print(<Print>s, flags);
                throw new Error("Print");
                // break;
            }
            case ForStatement: {
                return this.forStatement(<ForStatement>s, flags);
            }
            case WhileStatement: {
                return this.whileStatement(<WhileStatement>s, flags);
            }
            case IfStatement: {
                return this.ifStatement(<IfStatement>s, flags);
            }
            case Raise: {
                return this.raise(<Raise>s, flags);
            }
            case TryExcept: {
                return this.tryExcept(<TryExcept>s, flags);
            }
            case TryFinally: {
                return this.tryFinally(<TryFinally>s, flags);
            }
            case Assert: {
                return this.assert(<Assert>s, flags);
            }
            case ImportStatement:
                return this.importStatement(<ImportStatement>s, flags);
            case ImportFrom:
                return this.importFrom(<ImportFrom>s, flags);
            case Global:
                throw new Error("Gloabl");
            // break;
            case Expr:
                return this.expr((<Expr>s), flags);
            case Pass:
                throw new Error("Pass");
            // break;
            case BreakStatement:
                return this.breakStatement((<BreakStatement>s), flags);
            case ContinueStatement:
                return this.continueStatement(<ContinueStatement>s, flags);
            */
            default: {
                throw new Error("statement(s = " + JSON.stringify(s) + ", flags = " + flags + ")");
            }
        }
    };
    Transpiler.prototype.assert = function (a, flags) {
        throw new Error("Assert");
    };
    Transpiler.prototype.breakStatement = function (b, flags) {
        /*
        if (this.u.breakBlocks.length === 0)
            throw new SyntaxError("'break' outside loop");
        break;
        */
        throw new Error("BreakStatement");
    };
    Transpiler.prototype.classDef = function (c, flags) {
        throw new Error("ClassDef");
    };
    Transpiler.prototype.continueStatement = function (c, flags) {
        throw new Error("ContinueStatement");
    };
    Transpiler.prototype.forStatement = function (fs, flags) {
        throw new Error("ForStatement");
    };
    Transpiler.prototype.functionDef = function (f, flags) {
        throw new Error("FunctionDef");
    };
    Transpiler.prototype.ifStatement = function (fs, flags) {
        throw new Error("IfStatement");
    };
    Transpiler.prototype.importFrom = function (i, flags) {
        // const node = new Node();
        // node.fi
        throw new Error("ImportFrom");
    };
    Transpiler.prototype.importStatement = function (i, flags) {
        throw new Error("ImportStatement");
    };
    Transpiler.prototype.returnStatement = function (rs, flags) {
        /*
        if (this.u.ste.blockType !== FunctionBlock)
            throw new SyntaxError("'return' outside function");
        if (rs.value)
            out("return ", this.vexpr(rs.value), ";");
        else
            out("return null;");
        */
        throw new Error("ClassDef");
    };
    Transpiler.prototype.deleteExpression = function (de, flags) {
        throw new Error("DeleteExpression");
    };
    Transpiler.prototype.assign = function (assign, flags) {
        // const node = new Node();
        // node.finishAssignmentExpression(operator, left, right);
        /*
        var n = assign.targets.length;
        var val = this.vexpr(assign.value);
        for (var i = 0; i < n; ++i)
            this.vexpr(assign.targets[i], val);
        */
        // return node;
        throw new Error("Assign");
    };
    Transpiler.prototype.augAssign = function (aa, flags) {
        throw new Error("FunctionDef");
    };
    Transpiler.prototype.expr = function (expr, flags) {
        console.log("" + JSON.stringify(expr));
        if (expr instanceof Num) {
            return ts.createLiteral(expr.n.value);
        }
        throw new Error("Expr");
    };
    Transpiler.prototype.print = function (p, flags) {
        throw new Error("Print");
    };
    Transpiler.prototype.raise = function (raise, flags) {
        throw new Error("Raise");
    };
    Transpiler.prototype.tryExcept = function (te, flags) {
        throw new Error("TryExcept");
    };
    Transpiler.prototype.tryFinally = function (tf, flags) {
        throw new Error("TryFinally");
    };
    Transpiler.prototype.whileStatement = function (ws, flags) {
        throw new Error("WhileStatement");
    };
    return Transpiler;
}());
function transpile(source) {
    var cst = parse(source);
    if (typeof cst === 'object') {
        var ast = astFromParse(cst);
        var st = symbolTable(ast);
        var t = new Transpiler(st, 0, source);
        var flags = 0;
        return t.module(ast, flags);
    }
    else {
        throw new Error("Error parsing source for file.");
    }
}

exports.parse = parse;
exports.parseTreeDump = parseTreeDump;
exports.astFromParse = astFromParse;
exports.astDump = astDump;
exports.tsCompile = compile;
exports.tsReset = resetCompiler;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.js.map
